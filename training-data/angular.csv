question,answer
"What is the preferred method for dependency injection in modern Angular (19+) components, services, and injectables, and why?","The preferred method is to use the `inject()` function. Constructor injection should only be used for specific legacy scenarios or framework interoperability needs. `inject()` is preferred because it is more type-safe concise reduces boilerplate and improves code readability compared to traditional constructor injection."
"Generate an Angular service called `ProductService` that uses the `inject()` function to inject the `HttpClient`. The service should have a method `getProducts()` that returns an Observable of `Product[]`. Convert this Observable to a signal for use in a component.","```typescript\nimport { Injectable, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProductService {\n  private http = inject(HttpClient);\n\n  getProducts(): Observable<Product[]> {\n    return this.http.get<Product[]>('/api/products');\n  }\n     // Convert the observable from to a signal to avoid async pipe in templates\n    productsSignal = toSignal(this.getProducts(), {initialValue: []});\n}\n```"
"Explain the difference between `providedIn: 'root'` and providing a service at the component level. When should each approach be used?","`providedIn: 'root'` creates a single shared instance of the service across the entire application (singleton). Component-level providers create a new instance of the service for each instance of the component and its children. Use `providedIn: 'root'` for services that should be shared globally (for example authentication or logging). Use component-level providers for services that should be scoped to a specific component and its children (for example form state or component-specific data)."
"How do you ensure type safety when using the `inject()` function?","Always use the generic type parameter with `inject()` to specify the type of the injected dependency. For example: `private readonly myService = inject<MyService>(MyService);` or if using an injection token `private readonly myService = inject<MyServiceInterface>(MyServiceToken);`."
"Describe how to implement dynamic component injection in Angular including the role of `ViewContainerRef` and `createComponent()` and the use of an `environmentInjector`.  Give a code example.","Dynamic component injection allows you to load components on demand. You use `ViewContainerRef` to get a reference to a container element in your template where the dynamic component will be inserted.  Then use `createComponent(ComponentClass, { viewContainerRef: ..., injector: ... })` to create an instance of the component and insert it into the view.  The `environmentInjector` ensures the component has access to the correct dependencies.\n\n```typescript\nimport { Component, ViewContainerRef, createComponent, inject, EnvironmentInjector } from '@angular/core';\nimport { DynamicComponent } from './dynamic.component';\n\n@Component({\n  selector: 'app-dynamic-host',\n  template: '<ng-container #container></ng-container>',\n})\nexport class DynamicHostComponent {\n  private viewContainerRef = inject(ViewContainerRef);\n    private environmentInjector = inject(EnvironmentInjector);\n\n  async loadComponent() {\n    this.viewContainerRef.clear(); // Clear any existing components\n    const { DynamicComponent } = await import('./dynamic.component');\n    const componentRef = createComponent(DynamicComponent, {\n      environmentInjector: this.environmentInjector,\n    });\n\n    this.viewContainerRef.insert(componentRef.hostView);\n  }\n}\n```"
"What are the key principles of the Angular Dependency Injection Ruleset?", "The core principles are: \n1.  **`inject()` as Default:** Always prefer `inject()` over constructor injection.\n2.  **Performance-Focused DI:** Design DI configurations with performance in mind (lazy loading dynamic injection).\n3.  **SOLID Principles:** Adhere to SOLID principles for robustness and maintainability."
"Explain the difference between lazy-loading *modules* and dynamic *component* injection. When would you choose one over the other?", "Lazy-loading modules (via the Angular Router) is suitable for feature-level code splitting.  It loads an entire module and its components when a route is activated.  Dynamic component injection is more appropriate for loading individual UI components on-demand *within* a component or feature (for example conditionally displaying a component based on user interaction).  Module lazy loading is for larger feature separation; dynamic component injection is for finer-grained on-demand component instantiation."
"Generate an Angular route configuration that lazy-loads a standalone component called `DashboardComponent` from a file called `dashboard.component.ts`.  Use the `loadComponent` syntax.", "```typescript\nimport { Routes } from '@angular/router';\n\nexport const routes: Routes = [\n  {\n    path: 'dashboard',\n    loadComponent: () => import('./dashboard.component').then(m => m.DashboardComponent)\n  }\n];\n```"
"What is the purpose of an Injection Token and how is it used to promote decoupling in Angular applications?", "Injection Tokens are used to provide interfaces or abstract types as dependencies instead of concrete classes. This promotes decoupling because components and services depend on the *abstraction* (the interface) rather than a specific *implementation*. This makes it easier to change or substitute implementations without modifying the consuming components.  You create an InjectionToken and then use it in providers (`useClass`, `useFactory`, etc.) to map the token to a concrete implementation."
"Provide an example of using an Injection Token to provide an interface called `Logger` with two different implementations: `ConsoleLogger` and `RemoteLogger`. Show how a component would inject the `Logger` interface.", "```typescript\nimport { Injectable, InjectionToken, inject, Component } from '@angular/core';\n\n// Define the interface\nexport interface Logger {\n  log(message: string): void;\n}\n\n// Create the Injection Token\nexport const LOGGER_TOKEN = new InjectionToken<Logger>('Logger');\n\n// Implementation 1: ConsoleLogger\n@Injectable({\n  providedIn: 'root',\n  useFactory: () => new ConsoleLogger(), // Could also use useClass: ConsoleLogger\n  deps: [LOGGER_TOKEN] //Optional deps\n})\nexport class ConsoleLogger implements Logger {\n  log(message: string) {\n    console.log(message);\n  }\n}\n\n// Implementation 2: RemoteLogger (Illustrative - would need actual remote logging logic)\n@Injectable()\nexport class RemoteLogger implements Logger {\n  log(message: string) {\n    // Send log message to a remote server\n    console.log('Sending to remote: ' + message);\n  }\n}\n\n\n// Component that injects the Logger interface\n@Component({\n  selector: 'app-my-component',\n  template: `<button (click)=\\\"logMessage()\\\">Log Message</button>`,\n  providers: [\n     //Choose the provider for the logger token here.\n    { provide: LOGGER_TOKEN, useClass: ConsoleLogger } // Or RemoteLogger\n  ]\n})\nexport class MyComponent {\n private logger = inject(LOGGER_TOKEN);\n\n  logMessage() {\n    this.logger.log('This is a test message!');\n  }\n}\n\n```"
"How does adhering to the Liskov Substitution Principle (LSP) improve the robustness of an Angular application using Dependency Injection?", "LSP states that objects of a superclass should be replaceable with objects of their subclasses without altering the correctness of the program.  In Angular DI this means that if you inject an interface (using an Injection Token) any concrete implementation provided for that token should be interchangeable without breaking the consuming components. This makes the application more flexible less brittle and easier to test because you can swap implementations easily."
"Explain the Single Responsibility Principle (SRP) and how it applies to designing Angular Services.", "SRP states that a class (or service) should have only one reason to change.  In Angular Services this means a service should have a focused well-defined responsibility (for example data access user authentication). Avoid creating 'God object' services that handle too many unrelated tasks.  Focused services are easier to reuse test and maintain."
"How does interface-based programming with Injection Tokens in Angular implicitly support the Interface Segregation Principle (ISP)?", "ISP states that clients should not be forced to depend on methods they do not use.  By using Injection Tokens to provide *interfaces* instead of concrete classes you can create smaller more focused interfaces that represent specific functionalities.  Components then depend only on the interfaces they need promoting modularity and cohesion."
"Create a checklist for verifying that generated Angular code adheres to the advanced Dependency Injection practices.", "[ ] `inject()` Function as Default: Is the `inject()` function used as the primary method for dependency injection (not constructor injection except for justified legacy/interop cases)?\n[ ] Type Safety with `inject()`: Is the generic type parameter consistently used with `inject()` for type safety?\n[ ] Dynamic Component Injection (Where Applicable): Is dynamic component injection considered and implemented for UI features suitable for on-demand loading or modularity?\n[ ] Lazy Loading Modules/Components (Route-Based): Is route-based lazy loading configured for feature modules or standalone components to optimize initial load time?\n[ ] Factory Providers for Complex Logic: Are Factory Providers used where dependency creation requires complex logic runtime configuration or asynchronous operations?\n[ ] Injection Tokens for Interfaces (Decoupling): Are Injection Tokens used to provide interfaces as dependencies promoting decoupling and substitutability?\n[ ] Provider Scope Management (`providedIn: 'root'` vs. Component-Level): Is provider scope ( `providedIn: 'root'` or component-level ) appropriately chosen based on the intended service sharing and lifecycle?\n[ ] SOLID Principles Adherence (LSP SRP ISP): Does the DI design adhere to SOLID principles particularly LSP and SRP ensuring robustness and maintainability?\n[ ] Performance-Conscious DI: Is the DI configuration optimized for performance considering lazy loading dynamic injection and efficient provider strategies?"
"What are the core architectural principles of the Angular Architecture Generation Ruleset?", "The core architectural principles are:\n1. Component-Based Architecture\n2. Standalone Components\n3. Services for business logic\n4. Smart vs Dumb Components\n5. Data Down Actions Up\n6. Lazy Loading"
"Explain the difference between 'Smart' (Container) components and 'Dumb' (Presentational) components in Angular and why this distinction is important.", "Smart components are responsible for data fetching state management and business logic. Dumb components are primarily focused on rendering UI based on inputs with minimal or no internal logic. Smart components orchestrate and provide data to Dumb components. This pattern promotes component reusability testability and separation of concerns. Dumb components are reusable UI building blocks while Smart components manage data flow."
"Describe the 'Data Down Actions Up' pattern in Angular component communication. Why is this pattern preferred over two-way data binding?", "Data Down Actions Up is a unidirectional data flow pattern. Parent components pass data *down* to child components via Inputs. Child components communicate events/actions *up* to parent components via Outputs. This improves predictability simplifies debugging and makes data flow easier to manage. Two-way data binding can make it harder to track changes and reason about the application's state."
"What is the primary mechanism for dependency injection in modern Angular (19+) and why is it preferred over constructor injection?", "The primary mechanism is the `inject()` function. It is preferred over constructor injection because it improves type safety conciseness and adheres to modern Angular patterns. `inject()` provides a cleaner and more type-safe alternative."
"Explain the importance of managing provider scope in Angular (root vs. component-level).", "Provider scope determines the lifecycle and sharing of a dependency. `providedIn: 'root'` creates a single application-wide instance (singleton). Component-level providers create a new instance for each component and its children. Choosing the correct scope ensures dependencies are available where needed and follow appropriate instantiation patterns (singleton vs component-specific)."
"What is the primary mechanism for managing reactive state in Angular 19+ and what are its advantages?", "Angular Signals are the primary mechanism for managing reactive state in Angular 19+. Signals provide a performant efficient and type-safe approach to state management minimizing change detection overhead. The main APIs are `signal()`, `computed()`, `effect()`, `input()`, and `output()`."
"How should application-wide shared state be managed in an Angular application using Signals?", "Application-wide shared state should be managed within Angular Services using Signals. Components should consume and react to signals exposed by services not duplicate state management logic. Services act as central state repositories."
"What are the key benefits of using `OnPush` change detection strategy in Angular components?", "`OnPush` change detection significantly reduces change detection overhead and improves application performance. It limits change detection cycles to only components that have received input changes or triggered events. This minimizes unnecessary computations."
"Explain how to implement deferred loading in Angular using `@defer` blocks. What are the benefits?", "Deferred loading using `@defer` blocks allows you to optimize initial load time by deferring the loading of non-critical UI sections components and resources. You wrap the content you want to defer in an `@defer` block.  This reduces the initial bundle size and improves page load speed. You can specify triggers like `on viewport`, `on interaction`, `on timer`, or `when` (conditional)."
"How can you minimize DOM operations and layout thrashing in Angular components to improve performance?", "Minimize direct DOM manipulations and operations that trigger layout reflows within components lifecycle hooks or effects. Use Angular's rendering pipeline and data binding. If DOM operations are necessary batch them defer them or use techniques to reduce layout recalculations."
"Why is it important to organize an Angular application into modular Feature Modules (or feature folders for standalone components)?", "Modular Feature Modules (or feature folders for standalone components) encapsulate related components services and functionality. This promotes modularity encapsulation and independent feature development and maintenance. It improves code organization reduces dependencies and makes large applications more manageable and scalable."
"What are the benefits of defining clear and well-documented boundaries and APIs for Angular components and services?", "Well-defined APIs and boundaries improve component and service reusability testability and maintainability. Clear interfaces make it easier to understand how different parts of the application interact and reduce the risk of unintended side effects."
"Why is it important to adhere to consistent coding styles and conventions in an Angular application?", "Consistent coding style is crucial for code maintainability and collaboration. It makes code easier to read understand and contribute to by multiple developers. Following established style guides promotes code quality and reduces cognitive load."
"Explain the importance of a comprehensive testing strategy in Angular applications (unit integration E2E tests).", "A comprehensive testing strategy ensures code quality application robustness and prevents regressions. Unit tests test individual components and services. Integration tests verify interactions between components and services. E2E tests validate end-to-end user flows. Automated testing is crucial for long-term maintainability."
"What is the KISS principle and how does it apply to Angular architecture?", "KISS (Keep It Simple Stupid) encourages simplicity in design. In Angular architecture favor the simplest solution that meets requirements and avoid unnecessary complexity or over-engineering. Simpler code is easier to understand maintain debug and test."
"What is the DRY principle and how can it be applied in Angular development?", "DRY (Don't Repeat Yourself) advocates for avoiding code duplication. In Angular extract reusable code patterns UI components services and logic into reusable modules components services mixins or functions. Reusable building blocks reduce development effort promote code sharing and improve code quality."
"Create a checklist for verifying that generated Angular application code and architecture adheres to the expert-level ruleset.", "[ ] Component-Based Architecture: Is the application structured as a hierarchy of reusable independent components?\n[ ] Standalone Components (Default): Are Standalone Components used as the default component type (for new applications and refactoring)?\n[ ] Services for Business Logic & State: Are services used to encapsulate business logic data access and shared state keeping components focused on UI?\n[ ] Smart vs. Dumb Components Pattern: Is there a clear distinction between Smart (Container) and Dumb (Presentational) components?\n[ ] Data Down Actions Up (One-Way Data Flow): Is a unidirectional data flow pattern (\"Data Down Actions Up\") enforced in component communication?\n[ ] Lazy Loading Feature Modules (Route-Based): Is lazy loading configured for Feature Modules (or standalone components as routes) via the Angular Router to optimize initial load?\n[ ] `inject()` for Modern DI (Default): Is the `inject()` function used as the primary DI mechanism (not constructor injection)?\n[ ] Injection Tokens for Decoupling: Are Injection Tokens used to provide interfaces/abstract types for dependencies (promoting decoupling)?\n[ ] Provider Scope Management (Root vs. Component): Is provider scope managed appropriately based on service sharing needs (`providedIn: 'root'` vs. component-level)?\n[ ] Signals for Reactive State Management (Primary): Are Signals used as the primary mechanism for state management ( `signal()` `computed()` `effect()` `input()` `output()` )?\n[ ] Services for Shared State (Signal-Based Services): Is application-wide shared state managed in Angular Services using Signals?\n[ ] Immutable Data Patterns (Where Practical): Are immutable data patterns encouraged especially with OnPush and Signals?\n[ ] OnPush Change Detection (Default): Is `ChangeDetectionStrategy.OnPush` set as the default for standalone components?\n[ ] Deferred Loading (`@defer`) - Strategic Usage: Is deferred loading implemented using `@defer` blocks for non-critical UI sections and modules to optimize initial load?\n[ ] Minimal DOM Operations & Layout Reflows (Performance): Are DOM operations and layout reflows minimized in components lifecycle hooks and effects?\n[ ] Optimized Templates - Simple & Efficient Bindings: Are templates kept lean focused on data binding and free of complex logic or method calls?\n[ ] Modular Feature Modules (or Standalone Features): Is the application organized into modular Feature Modules or feature folders for standalone components?\n[ ] Clear Component & Service Boundaries (Well-Defined APIs): Are component and service boundaries clearly defined with well-documented APIs?\n[ ] Consistent Coding Style (Angular Style Guide Adherence): Is a consistent coding style followed throughout the application adhering to Angular Style Guide conventions?\n[ ] Comprehensive Testing Strategy (Unit Integration E2E): Is a comprehensive testing strategy implemented (Unit Integration E2E tests)?\n[ ] KISS Principle Applied (Simplicity): Is the KISS principle applied to component and service design favoring simplicity and avoiding over-engineering?\n[ ] DRY Principle Applied (Reusability): Is the DRY principle applied to avoid code duplication and promote reusability of code patterns components and services?\n[ ] SOLID Principles Guiding Architecture (Overall Design): Are SOLID principles (especially LSP and SRP) considered as overarching guiding principles for the entire application architecture?"
"What are the core principles for generating Angular component templates using the new control flow syntax?", "The core principles are:\n1. Embrace Angular Control Flow: Always use the control flow syntax.\n2. Template Readability & Conciseness\n3. Performance Considerations Integrated\n4. Semantic HTML within Control Flow."
"When should you use the `@let` block in Angular templates?", "Use `@let` to declare local template variables for values that are used multiple times within a template section or to improve readability by assigning descriptive names to expressions. It is also commonly used with the async pipe."
"How do you use the `@let` block in combination with the `async` pipe to handle Observables in templates?", "You use `@let` to unwrap the resolved value of an Observable.  For example: `@let dataValue = myObservable$ | async;`.  This allows you to access the value directly in the template without manual subscriptions."
"When should you use `@if` blocks in Angular templates, and how do you handle multiple conditional branches?", "Use `@if` for straightforward conditional rendering based on boolean expressions. Use `@else if` and `@else` blocks for mutually exclusive branches and to create exhaustive conditional rendering logic."
"How should the AI Agent automatically handle cases where `@if` conditions are always true or always false?", "The AI Agent should automatically remove `@if` blocks if the checked condition is always true or always false based on static analysis.  It should simplify the template by directly rendering the relevant content and removing the unnecessary conditional block and inform the user of the simplification."
"When should you use `@for` blocks, and what is the crucial performance optimization you *must* always implement with `@for`?", "Use `@for` for rendering lists or collections of data.  You *must* always implement the `trackBy` function to efficiently track item identity and minimize DOM updates during list changes."
"What is the purpose of the `trackBy` function in `@for` loops, and what kind of identifier should it use?", "The `trackBy` function helps Angular track item identity in a list. It should use a *unique and stable identifier* for each item (e.g., an item ID). This allows Angular to reuse DOM elements efficiently and minimize rendering overhead when the list is updated."
"How do you handle asynchronous data (Observables) in templates using the new control flow syntax and best practices?", "Use the `async` pipe in combination with `@let` to unwrap and access the resolved value.  Example: `@let dataValue = myObservable$ | async;`. Avoid manual subscriptions or complex async handling within templates."
"How can you conditionally render template sections based on the state of asynchronous data (e.g., loading, data available, error)?", "Combine `@if` with signals that represent the async data loading state (e.g., `isLoadingSignal`, `dataAvailableSignal`). This provides fine-grained control over conditional rendering based on the asynchronous data lifecycle."
"Why is it important to keep Angular templates focused primarily on data display and structural rendering?", "Keeping templates lean and focused on data presentation improves template maintainability testability and performance. Complex logic belongs in the component class not the template."
"Create a checklist for verifying that generated Angular templates with control flow adhere to the ruleset.", "[ ] Angular Control Flow Syntax: Is Angular control flow syntax (`@let` `@if` `@for`) used exclusively for conditional and iterative rendering (no legacy `*ngIf` `*ngFor` `ng-template`)?\n[ ] `@let` for Local Variables & Async Data: Is `@let` used appropriately for local variable declarations and for unwrapping async data using `async` pipe?\n[ ] `@if` for Conditional Rendering - Clear Conditions: Are `@if` blocks used for clear and straightforward conditional rendering based on boolean expressions?\n[ ] `@for` for Iteration - `trackBy` Implemented: Are `@for` loops used for iterative rendering with `trackBy` function *always* implemented for efficient list updates?\n[ ] Unnecessary `@if` Condition Removal (AI Check): Has the AI agent automatically removed any `@if` blocks with conditions that are always true or always false? (and informed user if so)\n[ ] Clean and Consistent Template Indentation: Is template code properly indented for readability and visual structure?\n[ ] Template Comments (Judicious Use - Complexity Only): Are template comments used sparingly and only to explain genuinely complex or non-obvious control flow logic?\n[ ] Minimal Logic in Templates - Data Display Focus: Are templates kept lean and focused on data display avoiding complex logic or function calls directly in templates?"
"What are the core CSS and SCSS best practices that form the foundation of the Angular SCSS Generation Ruleset?", "The core principles are:\n1.  Semantic Selectors Over Generic and IDs\n2.  Efficient Selectors & Specificity Management\n3.  Responsive Design with Media Queries & Flexible Units\n4.  CSS Variables for Theming & Consistency"
"Why is it important to favor semantic selectors and meaningful CSS classes over generic selectors or IDs in Angular SCSS?", "Semantic selectors and classes improve code readability maintainability and performance by reducing specificity and creating a more logical styling structure that aligns with HTML semantics. IDs should be limited to JavaScript interactions or unique element identification not primarily for styling."
"How should responsive design be implemented in Angular SCSS?", "Use `@media` queries and flexible units (`rem`, `em`, `vw`, `vh`, `%`) for layouts typography and component styling. Use CSS variables to manage responsive breakpoints and theming consistently."
"What is the role of CSS variables in Angular SCSS and why are they important?", "CSS variables are used for theming reusable values and maintaining consistency across styles. They centralize design tokens (colors typography spacing etc.) for easy modification and theming control."
"What is the default styling approach for Angular components and why is it important?", "Component-scoped styles are the default using `.component.scss` files colocated with component TypeScript files. This ensures styles are encapsulated within the component and do not affect other parts of the application. Component encapsulation is crucial for modularity maintainability and preventing CSS conflicts."
"How do you style the host element of an Angular component using SCSS?", "Use the `:host` selector in the component's SCSS file. This targets the component's root element."
"What is `:host-context()` and when would you use it in Angular SCSS?", "`:host-context(selector)` applies styles to a component based on the presence of ancestor selectors in the component's context. It allows for context-aware styling based on parent classes attributes or other selectors in the DOM tree."
"When is it acceptable to use `::ng-deep` and what are the potential drawbacks?", "`::ng-deep` pierces Angular's style encapsulation to style descendant elements that are *not* part of the component's template. It should be used *very sparingly* and with caution as it breaks encapsulation and can lead to specificity issues. Consider alternatives like component theming or input properties for styling child components."
"How can SCSS nesting be used effectively within component stylesheets?", "Nest selectors within component SCSS to mirror the component's HTML structure. This improves style readability and organization. Avoid overly deep nesting which can increase specificity and reduce readability."
"How should SCSS variables be used in Angular applications (component and global scope)?", "Define SCSS variables in components (for component-specific theming) and in global stylesheet files (for application-wide theming). Use component-scoped variables for component-specific style customization and `:root` variables (or separate global SCSS files) for application-wide theme settings."
"What is the purpose of SCSS Mixins and when should they be used?", "Mixins encapsulate and reuse common style patterns responsive styles vendor prefixes or sets of CSS properties. Create mixins for frequently used style combinations to promote DRY (Don't Repeat Yourself) principles."
"When should SCSS Functions be used in Angular SCSS?", "Use SCSS Functions judiciously for dynamic CSS value calculations or more complex style logic when variables and mixins are not sufficient. Avoid overly complex functions if simpler features can achieve the same result."
"How can SCSS Modules (`@use`, `@forward`) be used to organize SCSS code in Angular applications?", "Use SCSS Modules (`@use` and `@forward`) to organize code into modular files create namespaces and manage dependencies. `@use` imports and namespaces SCSS files. `@forward` re-exports parts of modules. (Note: Angular CLI setup may need configuration for SCSS Modules)."
"What are some key considerations for writing performant SCSS in Angular applications?", "Write SCSS that generates efficient CSS. Avoid rules that trigger layout thrashing excessive repaints or inefficient selectors. Leverage hardware-accelerated properties and minimize layout recalculations."
"What accessibility considerations should be taken into account when generating SCSS for Angular applications?", "Ensure sufficient color contrast for text and UI elements. Implement clear and visible focus styles for interactive elements. Style semantic HTML elements appropriately. Do not rely solely on color to convey information."
"What CSS methodologies are recommended for maintaining scalable and organized SCSS in Angular applications?", "Employ methodologies like BEM (Block-Element-Modifier) OOCSS (Object-Oriented CSS) or similar component-focused approaches. Adapt these principles to fit Angular's component-scoped styling model."
"How should SCSS files be organized in an Angular project (component and global styles)?", "Organize SCSS files logically at the component level (within component folders) and at the global level (for application-wide styles). Within component files structure styles into logical sections. For global SCSS organize into files for variables mixins base styles components utilities and layout styles."
"Why is it important to use descriptive class names in Angular SCSS?", "Descriptive class names clearly indicate the purpose functionality or visual style of the element. They should be human-readable and reflect the role of the styled element. (Adhere to BEM/OOCSS naming if used)."
"When should comments be used in SCSS code and what should they explain?", "Comment SCSS code judiciously to explain complex style rules non-obvious logic or specific design decisions. Avoid over-commenting simple and self-explanatory rules."
"Create a checklist for verifying that generated Angular SCSS code adheres to the ruleset.", "[ ] Semantic Selectors & Meaningful Classes: Does the SCSS code prioritize semantic element selectors and meaningful CSS classes (avoiding generic `div/span` selectors and IDs where classes are more appropriate)?\n[ ] Efficient Selectors & Specificity Management: Are selectors efficient and specificity minimized? Is `!important` avoided?\n[ ] Responsive Design Implementation: Are `@media` queries and flexible units ( `rem` `em` `vw` `vh` `%` ) used for responsive layouts and typography?\n[ ] CSS Variables for Theming & Consistency: Are CSS variables (`:root` and component-scoped) extensively used for theming reusable values and consistency?\n[ ] Component-Scoped Styles (Encapsulation): Is SCSS code generated as component-scoped styles within `.component.scss` files?\n[ ] `:host` Selector Usage: Is `:host` selector used appropriately to style the component's host element?\n[ ] SCSS Nesting for Structure & Readability: Is SCSS nesting used effectively to mirror component HTML structure and improve readability (without over-nesting)?\n[ ] SCSS Mixins for Reusability: Are SCSS Mixins used to encapsulate and reuse common style patterns responsive rules or vendor prefixes?\n[ ] Performance-Focused SCSS (Minimize Layout Impact): Is SCSS code written with performance in mind minimizing layout triggers and inefficient CSS?\n[ ] Accessibility-Considerate SCSS (Contrast & Focus): Does SCSS code address accessibility by ensuring sufficient color contrast and clear focus styles for interactive elements?\n[ ] BEM/OOCSS or Similar Methodology: Is a CSS methodology like BEM or OOCSS used for class naming and stylesheet organization to ensure scalability and maintainability?\n[ ] Logical SCSS File Structure & Sections: Are SCSS files (component and global) logically structured and organized into relevant sections (variables mixins layout typography components utilities)?\n[ ] Descriptive Class Names (Semantic & Purposeful): Are class names descriptive meaningful and indicative of element purpose or visual style (following BEM/OOCSS conventions if applicable)?\n[ ] SCSS Comments for Complex Styles: Are comments used strategically to explain complex SCSS code logic or non-obvious style rules?"
"What are the core principles of the Angular Signals Generation Ruleset?", "The core principles are:\n1. Default to Signals.\n2.  Observables for Interop & External Data Streams"
"When should you use `signal()` in Angular?", "Use `signal()` to define mutable reactive state within components and services. It's the fundamental building block for creating reactive values."
"When should you use `computed()` in Angular?", "Use `computed()` to create derived signals that automatically recalculate their values based on dependencies on other signals. This ensures efficient updates for derived data."
"When should you use `effect()` in Angular?", "Use `effect()` for managing reactive side effects replacing traditional lifecycle hook logic where state-reactive behavior is needed. `effect()` automatically reacts to signal changes."
"When should you use `linkedSignal()` in Angular and why is it considered for advanced use cases?", "Use `linkedSignal()` judiciously for scenarios where you need a signal that maintains a direct two-way binding or dependency relationship with another signal. It's for specialized cases and should not be the default approach."
"How do you define component inputs in Angular 19+ using Signals, and how do you specify required vs. optional inputs?", "Use `input()` to define component inputs. Use `input.required<Type>()` for required inputs and `input<Type>(defaultValue)` for optional inputs with default values."
"How do you define component event emitters in Angular 19+ using Signals?", "Use `output()` to define component event emitters. Use `.emit(value)` on the `output()` signal to emit events."
"How do you bind to signals in Angular templates?", "Bind directly to signals by invoking them as functions (`{{ mySignal() }}`)."
"When should you use `@let` in templates when working with Signals?", "Use `@let` to declare local template variables for computed signal values that are used multiple times or when you need to access the computed value without repeated function calls."
"How can you combine `@defer` with Signals for deferred loading?", "`@defer` can be combined with signal-based conditions (e.g. `@defer (when mySignal()) { ... }`) to control deferred loading based on reactive state."
"What is the crucial performance optimization you must always use with `@for` loops when working with Signals or any iterable data?", "Always use the `trackBy` function with a unique identifier signal (or a stable identifier in the data) for efficient change detection and DOM updates."
"What is the absolute rule regarding Observables and template binding in Angular 19+?", "Never subscribe to Observables directly within Angular templates using the `async` pipe. Always convert Observables to Signals using `toSignal()` for template binding."
"Where should you use Signals to manage shared state in an Angular application?", "Use Signals in Angular Services to manage application-wide shared state. Services are the appropriate place for shared reactive state."
"What kind of names should you use for signals?", "Use clear and descriptive names that accurately reflect the state they hold or the derived value they compute."
"Create a checklist for verifying generated Angular code using Signals adheres to best practices.", "[ ] Signals as Primary State Management: Is Signal API (`signal()` `computed()` `effect()` `input()` `output()`) used as the *default* mechanism for component state management?\n[ ] Observables Converted to Signals for Templates: Are Observables (if used) converted to Signals using `toSignal()` *before* binding them in templates? (No `async` pipe for direct Observable binding in templates).\n[ ] `computed()` for Derived State: Are `computed()` signals used for all derived state based on other signals avoiding manual recalculations?\n[ ] `effect()` for Reactive Side Effects (Lifecycle Hook Alternatives): Is `effect()` used where state-reactive side effects are needed minimizing lifecycle hook usage for such logic?\n[ ] `input()` and `output()` for Component Communication: Are `input()` and `output()` used for component inputs and event emitters enforcing type safety?\n[ ] `@let` for Computed Values in Templates (Optimized Access): Is `@let` used for frequently accessed computed signals in templates to improve readability and potentially performance?\n[ ] `@for` with `trackBy` for Iteration Performance: Is `trackBy` function used with `@for` loops for efficient list rendering?\n[ ] Descriptive Signal Names and Code Comments: Are signals named descriptively? Is complex signal logic (especially in `computed()` and `effect()`) commented clearly?\n[ ] Signals in Services for Shared State: Is shared application state managed in Angular Services using Signals not duplicated in components?\n[ ] Performance Considerations: Are best practices for efficient signal usage considered (avoiding excessive signal updates in tight loops understanding change detection implications)?"
"What are the core performance principles outlined in the Angular Performance Generation Ruleset?", "Core principles are:\n1. Performance First Design\n2. Signals for Reactive State\n3. Deferred Loading with `@defer`\n4. OnPush Change Detection\n5. Minimize Template Computation."
"Why are Signals considered the cornerstone for reactive state management in terms of performance in Angular 19+?", "Signals provide the most performant and streamlined approach to reactive programming minimizing change detection overhead compared to Observables."
"What is the primary purpose of using `@defer` blocks in Angular?", "To implement deferred loading for non-critical UI sections and dependencies reducing the initial bundle size and improving initial render performance."
"Why is `ChangeDetectionStrategy.OnPush` the recommended default for all standalone components?", "OnPush enables Angular to efficiently skip change detection cycles for component subtrees that are *not* impacted by state changes minimizing unnecessary computations. It's crucial for large applications."
"Why should you avoid calling methods directly in Angular templates?", "Method calls in templates are re-executed on *every* change detection cycle potentially causing performance bottlenecks. Pre-compute values in the component class (using Signals or computed properties) and bind to these instead."
"What are the primary targets for `@defer` blocks to maximize performance benefits?", "Target non-critical UI elements components and content sections that are below-the-fold less frequently used or not essential for the initial user journey."
"What are the purposes of the `@placeholder`, `@loading`, and `@error` sub-blocks within `@defer`?", "These sub-blocks provide visual feedback to the user during deferred loading. `@placeholder` maintains layout and prevents content reflows. `@loading` indicates loading progress. `@error` handles loading failures."
"How should you choose the appropriate `@defer` trigger for a given section of content?", "Select triggers strategically based on the content and usage pattern. Use `on viewport` for below-the-fold content `on interaction`/`on hover` for content revealed on user interaction `on timer` for time-delayed loading `when` for conditional loading and consider `prefetch` strategies."
"Explain the purpose of the `minimum` and `after` parameters in `@placeholder` and `@loading` sub-blocks within `@defer`.", "These parameters fine-tune loading indicators and avoid UI flicker. `minimum` duration for placeholders prevents rapid flashes for fast-loading content. `after` in `@loading` delays the loading indicator until a threshold is reached."
"Why is it essential to use immutable data inputs with `OnPush` change detection?", "OnPush relies on *reference changes* in inputs to trigger change detection. Mutating input objects directly bypasses this mechanism. Always replace input objects/arrays with *new* references."
"How does component decomposition contribute to optimizing performance with `OnPush` change detection?", "Structure the application into smaller independent components where data flow is clearly defined via inputs and outputs. This maximizes OnPush effectiveness by allowing Angular to skip large portions of the component tree during updates."
"What is the preferred alternative to calling methods directly in templates for derived values?", "Use `computed()` signals for pre-computation in the component class. Bind templates directly to these computed signal values."
"When might you consider using Pure Pipes, and what are the potential tradeoffs?", "Use Pure Pipes *judiciously* for memoizing complex transformations or formatting of data that are computationally expensive and whose inputs are stable. However overuse can introduce overhead so profile and test their impact."
"Why should you minimize DOM operations and layout reflows within lifecycle hooks and `effect()` blocks?", "DOM operations especially layout reflows are performance-intensive. Minimizing these particularly during change detection is critical for application performance. Batch or defer them when possible."
"What should Angular templates primarily focus on, and what should be avoided within templates?", "Templates should focus on *data display* using Angular's binding syntax. Move complex logic data transformations and conditional rendering logic into the component class services or computed signals/effects."
"What are the key warnings and enforcement rules that the AI Agent must adhere to regarding performance?", "The AI Agent must:\n1. Warn on Anti-Patterns.\n2. Push Back on Performance Degradation.\n3. Warn on Unnecessary Complexity.\n4. Always Suggest Best Possible Performance Code"
"What specific anti-patterns should the AI Agent warn against or refuse to generate?", "Direct Observable subscriptions in templates method calls in templates overuse of `effect()` without clear purpose lack of OnPush in standalone components etc."
"How should the AI Agent respond if a user prompt requests code that would degrade performance?", "The AI should actively suggest a better performance-optimized solution using Signals `@defer` OnPush or template best practices and explain the benefits."
"What is the overarching principle regarding code generation and performance that the AI Agent must always follow?", "The AI Agent must *always* aim to generate the *best possible Angular code* based on established performance best practices."
"Create a checklist for the AI Agent to verify generated Angular code for performance optimization.", "[ ] Standalone Component & OnPush: Is the component a standalone component using `ChangeDetectionStrategy.OnPush`?\n[ ] Signals for State Management (Primary): Are Signals API ( `signal()` `computed()` `effect()` `input()` `output()` ) used as the core mechanism for component state management?\n[ ] `@defer` for Non-Critical UI: Are `@defer` blocks strategically used to lazy-load non-critical UI sections and dependencies?\n[ ] `@defer` Sub-blocks for Loading UI: Are `@placeholder` `@loading` `@error` sub-blocks implemented within `@defer` blocks for user feedback?\n[ ] Optimized `@defer` Triggers & Parameters: Are appropriate `@defer` triggers selected based on content and user interaction patterns? Are `minimum` and `after` parameters tuned for `@placeholder` and `@loading`?\n[ ] Computed Signals over Template Methods: Are `computed()` signals used to pre-compute values instead of calling methods directly in templates?\n[ ] Pure Pipes Judiciously for Memoization (Specific Cases): Are Pure Pipes used only for specific performance-critical data transformations not for general state management or as a substitute for `computed()` signals?\n[ ] Minimal DOM Operations in Lifecycle Hooks/Effects: Are DOM operations and layout reflow triggers minimized within lifecycle hooks and `effect()` blocks?\n[ ] Template Simplicity - Data Binding Focus: Are templates kept lean focused on data binding with simple expressions and free of complex logic or function calls?\n[ ] Warnings and Best Practices Adherence: Does the AI Agent generate warnings or push back against code that violates performance best practices or introduces unnecessary complexity?"
"Describe best practice for using the OnPush Strategy","Use the `OnPush` strategy to check a component only when its input reference changes when an event originates from within or when `markForCheck()` is called. Benefits:\n- Reduced change detection cycles\n- Improved predictability and performance"
"Provide code example of the OnPush Strategy", "```typescript\nimport { Component, ChangeDetectionStrategy } from \"@angular/core\";\n\n@Component({\n  selector: \"app-on-push\",\n  template: `<p>{{ data.title }}</p>`,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class OnPushComponent {\n  data = { title: \"Angular 19 Rocks!\" };\n}\n```"
"Give a guideline and example for using Providers and Dependency Injection","Guideline:  \n  Use the `inject()` function for dependency injection instead of traditional constructor injection. This approach is more type-safe and reduces boilerplate.\nExample:\n```typescript\nimport { Component, inject } from \"@angular/core\";\nimport { UserService } from \"./user.service\";\n\n@Component({\n  selector: \"app-profile\",\n  template: `<p>User profile works!</p>`,\n})\nexport class ProfileComponent {\n  // Instead of constructor(private userService: UserService) {…}\n  private userService = inject(UserService);\n}\n```"
"Give the recommended practices for SCSS Scoping","Encapsulation Mode:  \n  Use `ViewEncapsulation.Emulated` (the default) to scope styles.\nSeparation:  \n  Extract SCSS into separate files and leverage variables mixins and nesting (used sparingly)."
"Provide an example of SCSS Scoping","```typescript\nimport { Component, ViewEncapsulation } from \"@angular/core\";\n\n@Component({\n  selector: \"app-styled\",\n  templateUrl: \"./styled.component.html\",\n  styleUrls: [\"./styled.component.scss\"],\n  encapsulation: ViewEncapsulation.Emulated,\n})\nexport class StyledComponent {}\n```"
"Describe the latest Input syntax and provide an example","Guideline:  \n  Use the `input()` function (instead of the `@Input()` decorator) for type-safe component inputs.\nExample:\n```typescript\nimport { Component, input } from \"@angular/core\";\n\n@Component({\n  selector: \"app-child\",\n  template: `<p>{{ data().title }}</p>`,\n})\nexport class ChildComponent {\n  data = input<{ title: string }>();\n}\n```"
"Describe the latest Output syntax and provide an example","Guideline:  \n  Use the `output()` function to define event emitters.\nExample:\n```typescript\nimport { Component, output } from \"@angular/core\";\n\n@Component({\n  selector: \"app-child\",\n  template: `<button (click)=\\\"notifyParent()\\\">Click Me</button>`,\n})\nexport class ChildComponent {\n  readonly clicked = output<void>();\n\n  notifyParent() {\n    this.clicked.emit();\n  }\n}\n```"
"Describe the latest Model syntax and provide an example","Guideline:  \n  Use the `model()` function for two-way data binding.\nExample:\n```typescript\nimport { Component, model } from \"@angular/core\";\n\n@Component({\n  selector: \"app-toggle\",\n  template: `\n    <label>\n      <input type=\\\"checkbox\\\" [checked]=\\\"checked()\\\" (change)=\\\"toggle()\\\" />\n      Toggle\n    </label>\n  `,\n})\nexport class ToggleComponent {\n  checked = model<boolean>(false);\n\n  toggle() {\n    this.checked.set(!this.checked());\n  }\n}\n```"
"Provide best practices for Signals over Observables","Reactive State:  \n  Use Signals (and computed signals) to manage reactive state.\nAvoid Template Subscriptions:  \n  Never subscribe to an Observable in the template. Convert observables to signals with `toSignal()` from the interop package."
"Provide an example of using signals over observables", "```typescript\nimport { Component } from \"@angular/core\";\nimport { toSignal } from \"@angular/core/rxjs-interop\";\nimport { someStream$ } from \"./data.service\";\n\n@Component({\n  selector: \"app-reactive\",\n  template: `{{ someValue() }}`,\n})\nexport class ReactiveComponent {\n  someValue = toSignal(someStream$);\n}\n```"
"Provide an example of Component Injection","```typescript\nimport { Component, ViewContainerRef, Injector } from \"@angular/core\";\nimport { createComponent } from \"@angular/core\";\n\n@Component({\n  selector: \"app-dynamic-loader\",\n  template: `<ng-container #container></ng-container>`,\n})\nexport class DynamicLoaderComponent {\n  constructor(private viewContainerRef: ViewContainerRef, private injector: Injector) {}\n\n  async loadComponent() {\n    this.viewContainerRef.clear();\n    const { DynamicComponent } = await import(\"./dynamic.component\");\n    const componentRef = createComponent(DynamicComponent, {\n      environmentInjector: this.viewContainerRef.injector,\n    });\n    this.viewContainerRef.insert(componentRef.hostView);\n  }\n}\n```"
"Provide an example of Lazy Loading Components","```typescript\nimport { Routes } from \"@angular/router\";\n\nexport const routes: Routes = [\n  {\n    path: \"feature\",\n    loadComponent: () => import(\"./feature.component\").then((m) => m.FeatureComponent),\n  },\n];\n```"
"Provide an example of using Factory Providers","```typescript\nimport { Injectable } from \"@angular/core\";\n\nexport function loggerFactory() {\n  return new Logger(\"AppLogger\");\n}\n\n@Injectable({\n  providedIn: \"root\",\n  useFactory: loggerFactory,\n})\nexport class Logger {\n  constructor(private name: string) {}\n\n  log(message: string) {\n    console.log(`[${this.name}] ${message}`);\n  }\n}\n```"
"What are additional Angular 19 Guidelines?","Standalone Components and Strict Standalone Enforcement,\nEmbrace Signals and New Reactivity APIs,\nZoneless Angular,\nIncremental Hydration & Event Replay (SSR),\nModernized Dependency Injection,\nImmutability and Type Safety,\nTemplate Best Practices"
"Describe the default behavior of Standalone Components and Strict Standalone Enforcement","Angular 19 now defaults to standalone components. Ensure that non-standalone components are migrated if needed.\nEnable `strictStandalone` in your `tsconfig.json` to enforce standalone components."
"Provide the compiler flag change for Standalone Components and Strict Standalone Enforcement", "```json\n{\n  \"angularCompilerOptions\": {\n    \"strictStandalone\": true\n  }\n}\n```"
"What should you embrace for Signals and New Reactivity APIs?","Use signals computed signals and linked signals for reactive state.\nReplace lifecycle hook logic with reactive effects when possible.\nAvoid traditional lifecycle hooks if you can manage state with signals."
"How can you prepare your app for Zoneless Angular?","Use `OnPush` change detection.\nEmbrace signals for fine-grained reactivity.\nTest your app with the experimental zoneless provider if available."
"What is Incremental Hydration and Event Replay","Incremental Hydration:  \n  Use `@defer` syntax in your templates to lazily hydrate components as they enter the viewport.\nEvent Replay:  \n  Enable event replay to capture and replay user interactions while your app loads."
"Provide an example of implementing Incremental Hydration & Event Replay (SSR)","```typescript\nimport { provideClientHydration, withIncrementalHydration } from \"@angular/platform-browser\";\n\nbootstrapApplication(AppComponent, {\n  providers: [provideClientHydration(withIncrementalHydration())],\n});\n```"
"Describe best practice for Modernized Dependency Injection","Use the new `inject()` function to simplify dependency injection.\nInitialize services and reactive state directly as class fields using `inject()`."
"Describe Immutability and Type Safety guidelines","Use `readonly` modifiers and utility classes for arrays tuples and function arguments to enforce immutability.\nAvoid the `any` type and excessive use of the non-null assertion operator (`!`). Instead use optional chaining (`?.`) and nullish coalescing (`??`)."
"Describe Template Best Practices", "No Inline Styles:  \n  Never use inline styles; maintain styles in dedicated SCSS/CSS files.\nAvoid Calling Methods in Templates:  \n  Use signals or getters sparingly; compute values in the component class to improve performance.\nSelf-Closing Void Elements:  \n  Always use self-closing tag syntax for void elements (e.g. `<img />` `<input />`)."