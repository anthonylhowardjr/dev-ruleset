question,answer
"What is the main objective of extending the TypeScript Variable Declaration Ruleset to include Destructuring?", "To guide AI agents in effectively utilizing destructuring (objects arrays tuples) for improved readability conciseness efficiency and maintainability in TypeScript code."
"When should you use object destructuring?", "Utilize object destructuring to concisely extract properties from objects when accessing multiple properties within a specific scope."
"Give a code example of object destructuring in function parameters.", "```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction displayUserInfo({ name, email }: User): void { // Object destructuring\n  console.log(`Name: ${name}, Email: ${email}`);\n}\n```"
"When should you use array destructuring?", "Use array destructuring to concisely extract elements from arrays when accessing elements by their *index* particularly for small fixed-size arrays."
"Give a code example of array destructuring.", "```typescript\nfunction getCoordinates(): [number, number] {\n  return [10, 20];\n}\n\nconst [x, y] = getCoordinates(); // Array destructuring\nconsole.log(`X: ${x}, Y: ${y}`);\n```"
"When is tuple destructuring particularly important and why?", "Utilize tuple destructuring *extensively* when working with tuples. It's the idiomatic and best practice approach enforcing structure and type-safe access."
"Give a code example of tuple destructuring.", "```typescript\ntype StatusResult = [boolean, string | null];\n\nfunction processTask(): StatusResult {\n  return [true, \"Task completed successfully\"];\n}\n\nconst [success, message] = processTask(); // Tuple destructuring\n```"
"When should you rename properties during object destructuring?", "Use property renaming in object destructuring when necessary to provide more contextually relevant or descriptive variable names in the current scope."
"Give a code example of renaming properties during object destructuring.", "```typescript\ninterface ApiUserData {\n  user_name: string;\n  email_address: string;\n}\n\nfunction processApiData(apiData: ApiUserData): void {\n  const { user_name: displayName, email_address: userEmail } = apiData; // Renaming\n  console.log(`Display Name: ${displayName}, Email: ${userEmail}`);\n}\n```"
"How do you handle optional or potentially missing properties/elements during destructuring?", "Utilize default values in destructuring (e.g. `{ propertyName = defaultValue }`, `[elementVariable = defaultValue]`)."
"Give a code example of using default values in object destructuring.", "```typescript\ninterface ProductConfig {\n  discountPercentage?: number;\n  taxRate?: number;\n  shippingCost: number;\n}\n\nfunction calculateFinalPrice(config: ProductConfig): number {\n  const { discountPercentage = 0, taxRate = 0, shippingCost } = config; // Default values\n  // ... calculation logic ...\n}\n```"
"How do you selectively destructure, ignoring unneeded values?", "Use selective destructuring (ignoring unneeded properties or elements using `,` comma placeholders and omitting variable names)."
"Give a code example of selective destructuring, ignoring an unneeded array element.", "```typescript\nfunction processApiResponse(): [number, string, any] {\n  return [200, \"Success\", { data: ... }];\n}\n\nconst [status, message, /* data */ ] = processApiResponse(); // Ignore 'data'\n```"
"What should you avoid when using destructuring, concerning complexity?", "Avoid overly complex or deeply nested destructuring patterns in a single statement if they reduce readability."
"Create a checklist for AI Agents for verifying best practices in variable declaration and destructuring","[ ] `const` by Default (Prioritized incl. Destructuring): Is `const` used as default for variable declarations *including* variables created via destructuring (and `let` only when mutability is truly required)?\n[ ] `var` Forbiddden (No `var` in Destructuring also): Is `var` keyword completely avoided even within destructuring contexts?\n[ ] Block Scoping ( `let` & `const` in Smallest Scopes - Applies to Destructured Variables): Are `let` and `const` declarations (including destructured variable declarations) used within the smallest necessary scope (block scope)?\n[ ] Initialization at Declaration (Preferred - Destructuring): Are variables initialized at declaration including those initialized via destructuring for improved readability?\n[ ] Explicit Type Annotations (Destructured Variables & Functions): Are explicit type annotations used for destructured variables especially in function signatures and for non-primitive or complex destructured types?\n[ ] Descriptive Variable Names (Destructured Variables also): Are descriptive and meaningful variable names used including for variables created through destructuring to clearly indicate their purpose?\n[ ] CamelCase Naming (Destructured Variables): Is camelCase naming consistently followed for *destructured variable names*?\n[ ] No Variable Shadowing (Destructured Variables also): Is variable shadowing avoided even when naming destructured variables within scopes?\n[ ] Principle of Least Scope (Destructured Variables): Is the principle of least scope applied to destructured variables declaring them in the smallest possible scope of use?\n[ ] `for...of` Loops for Iterables (Iteration & Destructuring Context): Are `for...of` loops preferred for simple iterable iteration even when working with destructured elements within loops?\n[ ] Global Scope Variables Minimized (No Globals via Destructuring either): Is global scope variable declaration minimized ensuring destructured variables are also not inadvertently declared globally?\n[ ] Object Destructuring for Concise Property Access (When Multiple Properties Used): Is object destructuring used effectively to concisely access *multiple* object properties within a scope improving readability?\n[ ] Array Destructuring for Indexed Element Extraction (Small Arrays): Is array destructuring used appropriately to concisely extract elements from *small* fixed-size arrays by index for improved clarity over numerical index access?\n[ ] Tuple Destructuring for Fixed-Size Structures (Mandatory for Tuples): Is tuple destructuring *always used* when working with tuples to access tuple elements based on their position enforcing tuple structure?\n[ ] Property Renaming in Object Destructuring (Clarity-Driven): Is property renaming in object destructuring used *judiciously* and *only* when it genuinely improves contextual clarity or avoids naming conflicts?\n[ ] Default Values in Destructuring (Optional & Missing Handling): Are default values in destructuring utilized to gracefully handle optional or potentially missing properties or array elements improving robustness?\n[ ] Selective Destructuring (Ignore Unused Values): Is selective destructuring used to intentionally ignore unneeded properties or array elements improving code conciseness and focus?\n[ ] Avoid Overly Complex/Deep Destructuring (Readability Prioritized): Is overly complex or deeply nested destructuring avoided if it compromises code readability? Is code clarity always prioritized over extreme destructuring verbosity?"
"What is the primary objective of the TypeScript Symbol Generation Ruleset?", "To guide AI agents in generating high-quality purposeful readable and maintainable TypeScript code that effectively and appropriately utilizes Symbols."
"When should you primarily use Symbols in TypeScript?", "Utilize Symbols primarily when you need to create *unique identifiers* or ensure *guaranteed key uniqueness*."
"When are Symbols semantically more appropriate as property keys?", "Use Symbols as property keys when non-string based keys are semantically more appropriate or technically advantageous."
"How do Symbols relate to controlled access (privacy) in TypeScript?", "Employ Symbols to create properties that are *less discoverable* and *less likely to be accidentally accessed*. Not true privacy, but privacy by convention."
"How do you create unique, local Symbols?", "Use `Symbol()` (invoking the `Symbol` constructor without `for` argument)."
"When should you use `Symbol.for()`?", "Use `Symbol.for('key')` when you need to create or retrieve Symbols from the *global Symbol registry* (shared Symbols)."
"Why are descriptive Symbol descriptions recommended?", "Provide descriptive string descriptions as the argument to `Symbol()` or `Symbol.for()` for debugging readability and documentation."
"How do you declare and access Symbol-keyed properties?", "Declare and access Symbol-keyed properties using *bracket notation* with a Symbol variable as the key."
"When should you utilize well-known Symbols?", "Utilize well-known Symbols when you need to customize or implement standard JavaScript/TypeScript language behaviors."
"What kind of variable names should you use for variables holding Symbol values?", "Use descriptive and meaningful variable names for variables that hold Symbol values."
"How should you manage the scope and visibility of Symbol variables intended for internal use?", "Declare Symbol variables in a private scope or in a way that clearly signals their internal or non-public intended usage."
"Should Symbols be used as a general-purpose replacement for string keys?", "Use Symbols judiciously and intentionally only when their unique properties provide a clear benefit. Do not overuse."
"Should Symbol-keyed properties be used in public APIs or DTOs?", "Avoid using Symbol-keyed properties in public APIs or Data Transfer Objects (DTOs). String keys for interoperability."
"Create an AI Agent verification checklist for TypeScript Symbol Generation.","[ ] Symbols Used Purposefully (Unique IDs Non-String Keys Controlled Access): Are Symbols used intentionally and purposefully for scenarios where their unique properties (uniqueness non-string keys convention-based privacy) provide a clear advantage or are they overused?\n[ ] `Symbol()` for Unique Local Symbols (Default for Uniqueness): Is `Symbol()` used (without `for`) when creating unique local Symbols where guaranteed uniqueness is required for identifiers or keys within a limited scope?\n[ ] `Symbol.for()` for Global Symbol Registry (Shared Symbols): Is `Symbol.for()` used (with string keys) only when Symbols need to be shared and recognized across different parts of the application or across realms and is its use justified by the need for a global Symbol registry?\n[ ] Descriptive Symbol Descriptions Provided (Debugging & Documentation): Are descriptive string descriptions provided as arguments to `Symbol()` and `Symbol.for()` constructors to improve code debugging and documentation?\n[ ] Symbol-Keyed Properties Declared with Bracket Notation (`[]`): Are Symbol-keyed properties declared and accessed using bracket notation (`[]`) with Symbol variables as keys (and dot notation avoided)?\n[ ] Well-Known Symbols Utilized for Standard Language Features: Are well-known Symbols (like `Symbol.iterator` `Symbol.toStringTag`) used appropriately to customize or implement standard JavaScript/TypeScript language behaviors when relevant?\n[ ] Descriptive Symbol Variable Names Used (Clarity of Symbol's Purpose): Are descriptive and meaningful variable names used for variables holding Symbol values clearly indicating the Symbol's purpose?\n[ ] Private or Internal Scope for Symbol Variables (Encapsulation Indicated): Are Symbol variables (intended for internal use) declared in a private scope or using naming conventions (e.g. underscore prefix) to clearly signal their internal or non-public nature?\n[ ] Judicious Use of Symbols - Not Overused as Default Keys: Are Symbols used judiciously and intentionally not as a general-purpose replacement for string keys or overused unnecessarily in the code?\n[ ] Symbol-Keyed Properties Avoided in Public APIs/DTOs (String Keys for Interoperability): Are Symbol-keyed properties avoided in public APIs of classes components services and DTOs/data structures intended for broader interoperability favoring string keys for public interfaces in most cases?"
"What is the primary objective of the TypeScript Type Manipulation Generation Ruleset?", "To guide AI agents in generating high-quality expressive type-safe and maintainable TypeScript code through the expert and judicious application of Type Manipulation techniques."
"How should you view TypeScript's type system in the context of code design?", "Embrace TypeScript's type system as a *powerful design tool* for expressing complex data structures enforcing contracts and enhancing code safety."
"What should be prioritized in all type manipulation constructs?", "Prioritize *clarity* and *readability* in all type manipulation constructs. Type definitions should serve as documentation."
"What are the primary motivations for using Type Manipulation techniques?", "Focus on *enhancing type safety* and *preventing runtime errors* as the primary motivation."
"What is the role of Type Aliases in Type Manipulation?", "Utilize Type Aliases extensively to give descriptive names to complex or reusable type constructs."
"When should you primarily use Interfaces in TypeScript?", "Use Interfaces primarily to define *contracts* or *shapes* for objects outlining the structure and types of properties."
"How should Utility Types be used for common type transformations?", "Utilize Utility Types strategically to perform common type transformations concisely and efficiently."
"What are some examples of common type transformations that Utility Types can perform?", "Make properties optional or required (`Partial`, `Required`). Enforce immutability (`Readonly`). Subset or exclude properties (`Pick`, `Omit`). Create map-like types (`Record`). Introspect function or class types (`ReturnType`, `Parameters`). Narrow types and perform set operations (`NonNullable`, `Extract`, `Exclude`)."
"How should Mapped Types be used for property transformations?", "Use Mapped Types to perform property-wise transformations on types iterating over the keys of a type."
"What is the role of the `keyof` type operator in conjunction with Mapped Types?", "Leverage the `keyof` type operator with Mapped Types to dynamically iterate over the keys of a type."
"How can you incorporate Conditional Types within Mapped Types for fine-grained control?", "Incorporate Conditional Types *within* Mapped Types to apply property-specific transformations based on name or type."
"When should you use Conditional Types in TypeScript?", "Use Conditional Types when you need to define types that dynamically resolve to different types based on type conditions."
"What is the purpose of the `infer` keyword within Conditional Types?", "Leverage the `infer` keyword within Conditional Types to infer a type from within the condition branch."
"How can Discriminated Unions and Conditional Types be combined for exhaustive type handling?", "Combine Discriminated Unions with Conditional Types to create type patterns that ensure exhaustive type handling."
"What is the overriding principle regarding readability and maintainability in Type Manipulation?", "Prioritize readability and maintainability above all else. Clarity over cleverness."
"Why is it important to comment complex Type Manipulation logic?", "Comment code to explain complex Type Manipulation logic particularly for Utility Type compositions Mapped Types or Conditional Types."
"How can you use Type Aliases to manage complexity in Type Manipulation?", "Utilize Type Aliases proactively to name and break down complex Type Manipulation expressions."
"Create a checklist for AI Agents regarding best practices in TypeScript Type Manipulation.","[ ] Utility Types Used Purposefully for Transformation & Reusability (Strategic Use): Are Utility Types used intentionally and purposefully for transforming types or creating reusable type patterns avoiding overuse or unnecessary complexity?\n[ ] `Partial<T>` for Optional Properties (Appropriate Use Cases): Is `Partial<T>` used effectively to create types with optional properties enhancing flexibility for data structures or update scenarios where optionality is semantically meaningful?\n[ ] `Required<T>` for Enforcing Mandatory Properties (Purposeful Strictness): Is `Required<T>` used judiciously and only when there is a genuine need to enforce mandatory properties and improve type strictness avoiding overuse if not semantically justified?\n[ ] `Readonly<T>` for Immutability (Data Integrity Rationale): Is `Readonly<T>` utilized purposefully and only when immutability is a genuine design requirement or enhances data integrity in specific scenarios avoiding overuse where mutability is intended or acceptable?\n[ ] `Pick<T K>` & `Omit<T K>` for Type Subsetting & Exclusion (Clarity & Focus): Are `Pick<T K>` and `Omit<T K>` employed effectively to create focused or simplified types by subsetting or excluding properties when it improves type granularity and code clarity avoiding overuse if simpler types are sufficient?\n[ ] `Record<K T>` for Map-like Types (Semantic Key-Value Maps): Is `Record<K T>` used appropriately to define type-safe map-like data structures with specific key and value types only when semantically representing map or dictionary-like data with structured keys?\n[ ] `ReturnType<T>` `Parameters<T>` `ConstructorParameters<T>` `InstanceType<T>` for Advanced Reflection (Judiciously Used): Are `ReturnType` `Parameters` `ConstructorParameters` and `InstanceType` used judiciously and only when genuinely needed for advanced type reflection higher-order type utilities or type-level metaprogramming scenarios avoiding overuse if simpler type operations are sufficient?\n[ ] `NonNullable<T>` `Extract<T U>` `Exclude<T U>` for Advanced Type Manipulation (Specific Needs): Are `NonNullable` `Extract` and `Exclude` Utility Types employed purposefully for advanced type narrowing or set operations only when these complex type manipulations are genuinely required for specific type logic or data filtering?\n[ ] Descriptive Type Alias Names for Utility Type Results (Clarity & Intent): Are descriptive and meaningful type alias names used for all type aliases created using Utility Types or other type manipulation techniques clearly indicating the transformation and purpose of the resulting type?\n[ ] Consistent Naming Conventions for Utility Type Aliases (Project-Wide Consistency): Are consistent naming conventions followed for Utility Type aliases throughout the project to enhance code organization discoverability and maintainability?\n[ ] Judicious and Purposeful Use of Utility Types (Avoid Over-Abstraction & Over-Engineering): Are Utility Types used judiciously and purposefully avoiding overuse or creating overly complex nested type expressions that reduce code readability without significant gains in type safety or expressiveness? Is simplicity always considered alongside type sophistication?\n[ ] Readability and Maintainability Prioritized (Clarity Over Complexity): Is code readability and maintainability consistently prioritized over striving for maximal conciseness or overly intricate Type Manipulation if it compromises code understandability? Is clarity always the ultimate guiding principle even if slightly more verbose but more understandable types are preferred in complex scenarios?\n[ ] Comments for Complex Type Manipulation Logic (Explain \"Why\" & \"How\"): Are comments used strategically and judiciously to explain complex Type Manipulation logic non-obvious type transformations or intricate type relationships where necessary focusing comments on explaining the \"why\" and \"how\" rather than restating the syntax?\n[ ] Type Aliases Used to Break Down Complex Types (Improved Maintainability): Are Type Aliases proactively used to name and break down complex Type Manipulation expressions into smaller more manageable and self-documenting type definitions to enhance code organization readability and long-term maintainability?"
"What is the primary objective of the TypeScript Utility Type Generation Ruleset?", "To guide AI agents in generating high-quality type-safe expressive and maintainable TypeScript code by effectively and appropriately utilizing Utility Types."
"What are Utility Types primarily used for in TypeScript?", "Utilize Utility Types primarily to *transform existing types* or *derive new types* based on existing ones in a *reusable and type-safe manner*."
"Should Utility Types be used in a way that maximizes code clarity?", "Employ Utility Types in a way that *enhances code clarity and readability*. Avoid overly complex compositions."
"How do Utility Types contribute to type safety and type inference?", "Leverage Utility Types to *enhance type safety* and improve TypeScript's type inference capabilities."
"When should you use the `Partial<T>` Utility Type?", "Use `Partial<T>` when you need to define a type where *all properties of type `T` become optional*."
"Give a code example demonstrating the use of `Partial<T>`.", "```typescript\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ntype PartialProduct = Partial<Product>; // All properties are optional\n```"
"When should you use the `Required<T>` Utility Type?", "Use `Required<T>` when you need to define a type where *all properties of type `T` become explicitly required*."
"Give a code example demonstrating the use of `Required<T>`.", "```typescript\ninterface ConfigOptions {\n  apiKey?: string;\n}\n\ntype StrictConfig = Required<ConfigOptions>; // apiKey is now required\n```"
"When should you use the `Readonly<T>` Utility Type?", "Utilize `Readonly<T>` to create a type where *all properties of type `T` become readonly* enforcing immutability."
"Give a code example demonstrating the use of `Readonly<T>`.", "```typescript\ninterface Settings {\n  theme: string;\n}\n\ntype ImmutableSettings = Readonly<Settings>; // theme is now readonly\n```"
"When should you use the `Pick<T, K>` Utility Type?", "Use `Pick<T, K>` to create a new type by selecting (picking) specific properties (`K`) from an existing type `T`."
"Give a code example demonstrating the use of `Pick<T, K>`.", "```typescript\ninterface Employee {\n  id: number;\n  name: string;\n  department: string;\n}\n\ntype EmployeeSummary = Pick<Employee, 'id' | 'name'>; // Only id and name\n```"
"When should you use the `Omit<T, K>` Utility Type?", "Use `Omit<T, K>` to create a new type by excluding specific properties (`K`) from an existing type `T`."
"Give a code example demonstrating the use of `Omit<T, K>`.", "```typescript\ninterface EventDetails {\n  name: string;\n  date: Date;\n  location: string;\n  privateNote: string; \n}\n\ntype PublicEventInfo = Omit<EventDetails, 'privateNote'>; // Exclude privateNote\n```"
"When should you use the `Record<K, T>` Utility Type?", "Use `Record<K, T>` to create a type that represents a record or map-like data structure."
"Give a code example demonstrating the use of `Record<K, T>`.", "```typescript\ntype StatusCode = 200 | 404 | 500;\n\ntype StatusMessages = Record<StatusCode, string>; // Status codes as keys, strings as values\n```"
"When should you use `ReturnType<T>`, `Parameters<T>`, `ConstructorParameters<T>`, and `InstanceType<T>`?", "Utilize for advanced type reflection and function/class introspection scenarios."
"Give a code example demonstrating the use of `ReturnType<T>` and `Parameters<T>`.", "```typescript\nfunction fetchData(url: string): Promise<any> { return Promise.resolve(); }\n\ntype FetchDataReturnType = ReturnType<typeof fetchData>; // Promise<any>\ntype FetchDataParametersType = Parameters<typeof fetchData>; // [url: string]\n```"
"When should you use `NonNullable<T>`, `Extract<T, U>`, and `Exclude<T, U>`?", "Employ for more advanced type narrowing type set operations and complex type manipulation."
"Give a code example demonstrating the use of `NonNullable<T>`, `Extract`, and `Exclude`.", "```typescript\ntype MaybeString = string | null | undefined;\ntype StringTypeOnly = NonNullable<MaybeString>; // string\n\ntype A = 'a' | 'b' | 'c';\ntype B = 'b' | 'c' | 'd';\ntype Common = Extract<A, B>; // 'b' | 'c'\ntype UniqueToA = Exclude<A, B>; // 'a'\n```"
"What kind of names should you use for type aliases created with Utility Types?", "Use descriptive and meaningful names for type aliases created using Utility Types."
"Should you maintain consistent naming conventions for Utility Type aliases?", "Maintain consistent naming conventions for type aliases created using Utility Types within a project."
"Should Utility Types be used excessively or for unnecessary abstraction?", "Use Utility Types judiciously and purposefully. Avoid overuse or creating overly complex nested type expressions."
"What should always be prioritized when using Utility Types, even if it means less conciseness?", "Prioritize code readability and maintainability. Favor clear types over complex Utility Type gymnastics."
"Create an AI agent Verification Checklist for the appropriate use of Utility Types.", "[ ] Utility Types Used Purposefully (Type Transformation & Reusability Focus): Are Utility Types used intentionally and purposefully for transforming existing types or creating reusable type patterns not overused or misused?\n[ ] `Partial<T>` Used for Optional Properties (Flexibility): Is `Partial<T>` used appropriately to create types with optional properties enhancing flexibility for data structures or update operations?\n[ ] `Required<T>` Used for Enforcing Mandatory Properties (Type Strictness): Is `Required<T>` used effectively to enforce that all properties of a type become explicitly required improving type strictness where needed?\n[ ] `Readonly<T>` Used for Immutability Enforcement (Data Integrity): Is `Readonly<T>` utilized to create immutable types enhancing data integrity and preventing unintended mutations where appropriate?\n[ ] `Pick<T K>` Used for Property Subsetting (Type Focus): Is `Pick<T K>` employed to create focused types by extracting specific properties from larger types improving type granularity and clarity?\n[ ] `Omit<T K>` Used for Property Exclusion (Type Simplification): Is `Omit<T K>` leveraged to create simplified types by excluding irrelevant properties from more complex types improving type definition clarity?\n[ ] `Record<K T>` Used for Map-like Types (Key-Value Mappings): Is `Record<K T>` utilized to define type-safe map-like data structures with specific key and value types enhancing type safety for key-value collections?\n[ ] `ReturnType<T>` `Parameters<T>` `ConstructorParameters<T>` `InstanceType<T>` Used for Advanced Reflection (Function/Class Introspection): Are `ReturnType` `Parameters` `ConstructorParameters` `InstanceType` used appropriately for advanced type reflection and function/class introspection scenarios leveraging these features only when genuinely beneficial for type manipulation or higher-order type utilities?\n[ ] `NonNullable<T>` `Extract<T U>` `Exclude<T U>` Used for Advanced Type Manipulation (Narrowing & Set Operations): Are `NonNullable` `Extract` `Exclude` Utility Types employed effectively for advanced type narrowing type set operations and complex type manipulation tasks when genuinely needed for sophisticated type-level logic?\n[ ] Descriptive Type Alias Names for Utility Types: Are descriptive and meaningful type alias names used for type aliases created with Utility Types clearly indicating the transformation and purpose of the resulting type?\n[ ] Consistent Naming Conventions for Utility Type Aliases: Are consistent naming conventions followed for Utility Type aliases throughout the project to enhance code organization and discoverability?\n[ ] Judicious and Purposeful Use of Utility Types (Avoid Over-Abstraction): Are Utility Types used judiciously and purposefully only when they genuinely enhance type safety reusability or expressiveness avoiding overuse or overly complex compositions that reduce readability?\n[ ] Readability and Maintainability Prioritized (Clarity Over Complexity): Is code readability and maintainability always prioritized over striving for maximal conciseness or overly intricate Utility Type expressions if it compromises code understandability? Is a balance maintained between type expressiveness and code clarity?"