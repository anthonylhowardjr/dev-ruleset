# TypeScript Symbol Generation Ruleset for AI Agents: Unique Keys & Controlled Access

**Objective:** To provide a concise ruleset for AI agents to generate **high-quality**, **purposeful**, **readable**, and **maintainable** TypeScript code that effectively and appropriately utilizes **Symbols**. This ruleset focuses on guiding AI agents in leveraging Symbols for creating unique identifiers, non-string based keys, and controlled property access, while adhering to TypeScript best practices.

**I. Core Principles of Symbol Usage:**

1.  **Symbols for Unique Identification & Key Uniqueness:** **RULE:** **UTILIZE Symbols primarily when you need to create *unique identifiers* or ensure *guaranteed key uniqueness*, especially in scenarios where avoiding naming collisions or creating truly distinct keys is paramount.** Symbols are best suited for situations where you need to:
    *   Create unique property keys on objects that should *not* clash with string-based keys or be accidentally overwritten or accessed from outside the intended scope.
    *   Implement metadata properties that are internal to a class or object and should not be part of the object's standard string-keyed interface.
    *   Work with well-known Symbols to customize built-in JavaScript/TypeScript behaviors (like iterators, `toStringTag`).

2.  **Symbols for Non-String Based Keys (When Semantically Appropriate):** **RULE:** **USE Symbols as property keys when non-string based keys are semantically more appropriate or technically advantageous.** Symbols, as primitive values distinct from strings, offer an alternative key type when you explicitly want to differentiate keys based on their symbolic identity rather than string-based names. However, for most common object property keys that represent named data or attributes, strings are typically sufficient and more readable. Use Symbols intentionally when their unique identity or non-string nature is specifically beneficial for your design.  **Rationale:** Symbols provide a unique, non-string key type in JavaScript/TypeScript. While most object properties are effectively keyed with strings, Symbols offer an alternative for cases where a unique, symbol-based key provides a semantic or technical advantage for separation, uniqueness, or controlled access.

3.  **Symbols for Controlled Access (Not True Privacy - Convention & Intent):** **RULE:** **Employ Symbols to create properties that are *less discoverable* and *less likely to be accidentally accessed or modified from outside the intended scope* (often within a class or module).**  Symbol-keyed properties are not truly *private* in the sense of runtime enforcement (like `#private` fields), but they are not enumerable by default and are less easily discovered through standard object property enumeration or reflection techniques, creating a form of "privacy by convention" and signaling developer intent that these properties are intended for internal use. However,  *always understand that Symbol-keyed properties are not true runtime privacy and can still be accessed via `Object.getOwnPropertySymbols()` or `Reflect.ownKeys()` if someone deliberately tries to bypass the intended encapsulation*. For true runtime privacy enforcement, use JavaScript's `#private` class fields instead. **Rationale:** Symbols offer a mechanism to create object properties that are intentionally less discoverable, providing a form of "privacy by convention."  This can be useful for marking properties as intended for internal use or implementation details, reducing the risk of accidental external access or modification and improving code encapsulation, even though Symbols do not provide strict runtime privacy like `#private` fields.  Choose the appropriate privacy mechanism based on your needs – `#private` for runtime enforcement, Symbols for convention-based encapsulation and reduced discoverability.

**II. Symbol Creation & Usage Rules:**

4.  **`Symbol()` for Unique, Local Symbols - Default for Uniqueness:** **RULE:** **USE `Symbol()` (invoking the `Symbol` constructor without `for` argument) to create *unique, local Symbols* when you need to generate a new, guaranteed-to-be-unique identifier *every time* you create a Symbol.**  `Symbol()` creates a new unique Symbol value each time it is called. This is the typical way to create Symbols when uniqueness within the application context is the primary requirement. **Rationale:** `Symbol()` is the standard constructor for generating new, unique Symbol values. It is the most common method for creating Symbols when you need a guaranteed-unique identifier for properties, internal markers, or unique keys where the Symbol's identity is more important than its optional description string.

5.  **`Symbol.for()` for Global Symbol Registry - Shared Symbols Across Application/Realm:** **RULE:** **USE `Symbol.for('key')` (invoking `Symbol.for('key')` with a string key) when you need to create or retrieve Symbols from the *global Symbol registry*.**  `Symbol.for('key')` either returns an *existing Symbol* from the global Symbol registry if a Symbol with the given string key already exists, or creates a *new Symbol* and registers it in the global registry if no Symbol with that key is found.  Use `Symbol.for()` when you need to ensure that Symbols with the same description string are *shared across different parts of your application or across different realms (like iframes or across different JavaScript files)*.**  Be mindful of potential global namespace considerations when using `Symbol.for()` - while Symbols themselves are unique, the string keys used in `Symbol.for()` are shared globally within the JavaScript realm.  Use `Symbol.keyFor(symbol)` to retrieve the string key associated with a Symbol created using `Symbol.for()`. **Rationale:** `Symbol.for()` provides a mechanism for creating and retrieving Symbols that are shared and recognized across different parts of a JavaScript application or even across different realms within the same JavaScript runtime. This is useful when you need a global registry of Symbols to ensure that Symbols with the same description are indeed the *same* Symbol object instance, enabling cross-module or cross-realm Symbol-based communication or identification.

6.  **Descriptive Symbol Descriptions (Optional, for Debugging & Documentation):** **RULE:** **PROVIDE *descriptive string descriptions* as the argument to `Symbol()` or `Symbol.for()` constructors (e.g., `Symbol('userProfileKey')`, `Symbol.for('app.event.userLoggedIn')`).** Symbol descriptions are optional but *highly recommended* for improving code debugging, readability, and documentation, particularly for Symbols used as object property keys or for complex Symbol usage scenarios. Symbol descriptions are displayed in developer tools and when converting Symbols to strings (e.g., in error messages or console logging) via `symbol.description`, aiding in understanding the purpose and context of different Symbols used in the code. **Rationale:**  Symbol descriptions, while not part of the Symbol's unique identity itself, provide valuable metadata for developers. Descriptive descriptions significantly improve code understandability, debugging (making Symbols identifiable in console logs and debuggers), and code maintainability by making the *purpose* and *meaning* of different Symbols clearer to developers working with the code.

7.  **Declare Symbol-Keyed Properties - Bracket Notation Access:** **RULE:** **Declare Symbol-keyed properties on objects using *bracket notation* with a Symbol variable as the key (e.g., `myObject[mySymbol] = 'value';`).** Access Symbol-keyed properties *also* using bracket notation with the same Symbol variable as the key (e.g., `const value = myObject[mySymbol];`).  Bracket notation `[]` is the *only way* to directly declare and access Symbol-keyed properties – dot notation (`myObject.mySymbol`) does *not* work for Symbol-keyed properties as it would be interpreted as a string key literally named "mySymbol".  **Rationale:** Bracket notation `[]` is the standard and *required* syntax for working with Symbol-keyed properties in JavaScript and TypeScript.  It correctly interprets a Symbol variable as a property key, while dot notation is reserved for string-based property access. Consistent use of bracket notation ensures correct declaration and retrieval of values associated with Symbol-keyed properties.

8.  **Well-Known Symbols (Standard Language Features - Use When Relevant):** **RULE:** **UTILIZE well-known Symbols (like `Symbol.iterator`, `Symbol.toStringTag`, `Symbol.asyncIterator`, etc.) when you need to customize or implement *standard JavaScript/TypeScript language behaviors or protocols* for your classes, objects, or data structures.**  Well-known Symbols are pre-defined Symbols that JavaScript and TypeScript use to define specific built-in functionalities. Use them to:
    *   Make objects iterable (implement `Symbol.iterator`).
    *   Customize the string representation of objects (`Symbol.toStringTag`).
    *   Implement asynchronous iteration (`Symbol.asyncIterator`).
    *   And other advanced language features driven by well-known Symbols.  **Rationale:** Well-known Symbols provide a standardized way to interact with and customize core JavaScript/TypeScript language features.  Using them correctly allows your classes and objects to integrate seamlessly with built-in language protocols and behaviors, enhancing interoperability and aligning with language conventions.

**III. Naming & Style Rules for Symbols:**

9.  **Descriptive Symbol Variable Names (Clarity of Symbol's Purpose):** **RULE:** **USE descriptive and meaningful *variable names* for variables that hold Symbol values.**  While Symbol descriptions (strings passed to `Symbol()` constructor) provide descriptions *within* the Symbol itself, variable names holding Symbol values should be descriptive in the code to indicate the *purpose* and *intent* of the Symbol's usage within the application context.  CamelCase naming is recommended for Symbol variables. Examples: `userProfileSymbol`, `_itemIteratorSymbol`, `_internalStateKey`. **Rationale:** Descriptive variable names for Symbol variables improve code readability by making it clear what each Symbol is *intended to represent or identify* within the application, even though the Symbol itself is fundamentally a unique, abstract identifier. Clear variable names supplement Symbol descriptions and enhance code understandability for developers working with Symbol-based properties or logic.

10. **Private or Internal Scope for Symbol Variables (Encapsulation & Convention):** **RULE:** **Declare Symbol variables (that are intended for internal use within a class, module, or component) in a *private scope* or in a way that clearly signals their *internal* or *non-public* intended usage.** For classes, declare Symbol variables as `private static readonly` class members if the Symbol is meant to be associated with the class and not instance-specific, or as `private readonly` instance members if the Symbol is instance-specific. For modules or functional scopes, declare Symbol variables using `const` within the module's or function's scope and avoid exporting or exposing them unnecessarily. Underscore prefixes (e.g., `_internalSymbol`) can also be used as a visual convention to indicate Symbols are meant for internal use (though this is just a convention and doesn't enforce runtime privacy like `#private`). Choose a consistent approach within your project to indicate the intended encapsulation and non-public nature of Symbols used for internal purposes.  **Rationale:**  Restricting the scope and visibility of Symbol variables enhances encapsulation and reduces the risk of accidental or unintended usage of Symbols from outside the intended context (e.g., from outside a class where they are used for internal properties).  Clear scope and naming conventions reinforce the concept of Symbols as often representing implementation details or internal markers that are not part of the public API or interface of a class or module.

**IV. Scope & Best Practices Rules for Symbol Usage:**

11. **Judicious Use of Symbols - Not for Every Property or Key:** **RULE:** **USE Symbols *judiciously and intentionally*, only when their unique properties (uniqueness, non-string keys, controlled access conventions) genuinely provide a clear benefit or solve a specific problem in the code design.**  **DO NOT overuse Symbols as a general-purpose replacement for string keys for all object properties or as a default approach for all identifiers.** Symbols are powerful for specific scenarios, but for many common cases, standard string-based keys and JavaScript/TypeScript's existing encapsulation and scope mechanisms are often sufficient and more straightforward.  Symbols introduce a slightly higher level of conceptual complexity; use them purposefully when their unique characteristics are truly needed and bring a tangible advantage. **Rationale:** Overusing Symbols unnecessarily can increase code complexity and potentially make code harder to read and understand if the benefits of Symbols are not clearly justified in each usage. Symbols are best applied strategically when their unique capabilities (uniqueness, non-string keys, convention-based privacy) provide a significant advantage in specific code design scenarios, not as a default coding style for all property keys or identifiers.

12. **Avoid Symbol-Keyed Properties in Public APIs or Data Transfer Objects (DTOs) - String Keys for Interoperability:** **RULE:** **AVOID using Symbol-keyed properties in *public APIs* of classes, components, services, or modules, or in *Data Transfer Objects (DTOs)* or data structures that are intended for serialization, data exchange, or communication across module boundaries or with external systems (APIs, libraries).** Public APIs and DTOs should generally rely on standard string-keyed properties for maximum interoperability, discoverability, and compatibility with JavaScript ecosystem conventions, serialization formats (like JSON), and external systems that may not understand or directly support Symbol-keyed properties. If you must expose Symbol-keyed properties in public APIs, do so exceptionally cautiously, document their purpose and usage very clearly, and ensure there is a strong justification for using Symbols in a public interface rather than more conventional string-keyed properties.  **Rationale:**  Symbol-keyed properties are inherently less discoverable and less interoperable compared to string-keyed properties, particularly when crossing module or system boundaries. Public APIs and DTOs are typically intended for broad consumption and interoperability, and string keys provide wider compatibility and better discoverability for most standard JavaScript/TypeScript tooling, libraries, and external systems.  Using Symbol-keyed properties in public interfaces can create usability challenges for consumers of those APIs and may not be easily understood or handled by external systems that expect standard string-keyed object properties.

**V. AI Agent Verification Checklist (TypeScript Symbol Generation):**

Before finalizing generated TypeScript code, verify adherence to these rules using the following checklist:

*   [ ] **Symbols Used Purposefully (Unique IDs, Non-String Keys, Controlled Access):** Are Symbols used intentionally and purposefully for scenarios where their unique properties (uniqueness, non-string keys, convention-based privacy) provide a clear advantage, or are they overused?
*   [ ] **`Symbol()` for Unique Local Symbols (Default for Uniqueness):** Is `Symbol()` used (without `for`) when creating unique, local Symbols where guaranteed uniqueness is required for identifiers or keys within a limited scope?
*   [ ] **`Symbol.for()` for Global Symbol Registry (Shared Symbols):** Is `Symbol.for()` used (with string keys) only when Symbols need to be shared and recognized across different parts of the application or across realms, and is its use justified by the need for a global Symbol registry?
*   [ ] **Descriptive Symbol Descriptions Provided (Debugging & Documentation):** Are descriptive string descriptions provided as arguments to `Symbol()` and `Symbol.for()` constructors to improve code debugging and documentation?
*   [ ] **Symbol-Keyed Properties Declared with Bracket Notation (`[]`):** Are Symbol-keyed properties declared and accessed using bracket notation (`[]`) with Symbol variables as keys (and dot notation avoided)?
*   [ ] **Well-Known Symbols Utilized for Standard Language Features:** Are well-known Symbols (like `Symbol.iterator`, `Symbol.toStringTag`) used appropriately to customize or implement standard JavaScript/TypeScript language behaviors when relevant?
*   [ ] **Descriptive Symbol Variable Names Used (Clarity of Symbol's Purpose):** Are descriptive and meaningful variable names used for variables holding Symbol values, clearly indicating the Symbol's purpose?
*   [ ] **Private or Internal Scope for Symbol Variables (Encapsulation Indicated):** Are Symbol variables (intended for internal use) declared in a private scope or using naming conventions (e.g., underscore prefix) to clearly signal their internal or non-public nature?
*   [ ] **Judicious Use of Symbols - Not Overused as Default Keys:** Are Symbols used judiciously and intentionally, not as a general-purpose replacement for string keys or overused unnecessarily in the code?
*   [ ] **Symbol-Keyed Properties Avoided in Public APIs/DTOs (String Keys for Interoperability):** Are Symbol-keyed properties avoided in public APIs of classes, components, services, and DTOs/data structures intended for broader interoperability, favoring string keys for public interfaces in most cases?
