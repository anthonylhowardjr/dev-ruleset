# Angular SCSS Generation Ruleset for AI Agents: Semantic, Accessible, Performant & Angular-Specific

**Objective:** To provide a concise ruleset for AI agents to generate *high-quality*, *semantic*, *accessible*, *performant*, and *maintainable* SCSS code specifically tailored for Angular applications. This ruleset emphasizes Angular-specific SCSS best practices, component-based styling, and efficient use of SCSS features within the Angular context.

**I. Core CSS & SCSS Best Practices (Foundation):**

1.  **Semantic Selectors Over Generic and IDs:** **RULE:** **ALWAYS favor semantic HTML element selectors and meaningful CSS classes for styling over generic selectors (like `div`, `span`) or IDs.**  Utilize classes for styling hooks and semantic element selectors for baseline styles based on HTML element type. Limit ID usage primarily for JavaScript interactions or unique element identification, *not* primarily for styling. **Rationale:** Semantic selectors and classes improve code readability, maintainability, and performance by reducing specificity and creating a more logical styling structure that aligns with HTML semantics.

2.  **Efficient Selectors & Specificity Management:** **RULE:** **GENERATE efficient CSS selectors that are as specific as necessary but no more.**  Avoid overly nested or complex selectors that increase specificity unnecessarily and can impact performance.  Understand CSS specificity rules and strive for the lowest specificity possible while still targeting intended elements effectively. Minimize use of `!important`. **Rationale:**  Efficient selectors improve CSS performance and reduce specificity conflicts. Lower specificity makes stylesheets easier to override and maintain.

3.  **Responsive Design with Media Queries & Flexible Units:** **RULE:** **ALWAYS implement responsive design using `@media` queries and flexible units ( `rem`, `em`, `vw`, `vh`, `%` ) for layouts, typography, and component styling.**  Use CSS variables (`:root` variables) to manage responsive breakpoints and theming consistently across media queries. **Rationale:** Responsive design is essential for modern web applications to adapt layouts and styles to various screen sizes and devices. Flexible units and media queries are fundamental for creating fluid and adaptable UIs.

4.  **CSS Variables for Theming & Consistency:** **RULE:** **UTILIZE CSS variables (`:root` variables and component-scoped variables) EXTENSIVELY for theming, reusable values, and maintaining consistency across styles.**  Define core colors, typography settings, spacing units, breakpoints, and other design tokens as CSS variables for easy modification and theming control. **Rationale:** CSS variables are crucial for creating maintainable, themeable, and consistent Angular applications. They centralize design tokens and allow for easy style adjustments and theming variations.

**II. Angular SCSS Specific Rules & Best Practices:**

5.  **Component-Scoped Styles - Encapsulation Default:** **RULE:** **ALWAYS generate component-scoped SCSS styles by default using Angular's component styling encapsulation.** Style Angular components using `.component.scss` files colocated with component TypeScript files. This ensures styles are encapsulated within the component and do not bleed into other parts of the application without explicit intent. **Rationale:** Component-scoped styles are a core principle in Angular for modularity, maintainability, and preventing CSS conflicts. Component encapsulation ensures styles are localized and predictable.

6.  **`:host` Selector for Component Host Element Styling:** **RULE:** **USE the `:host` selector in component SCSS files to style the component's *host element* (the custom element tag representing the component in the DOM).** `:host` allows you to target and style the component's root element from within its component-scoped stylesheet. **Rationale:** `:host` is the Angular-idiomatic selector for targeting the component's host element and applying styles directly to the component's root node.

7.  **`:host-context()` for Context-Aware Component Styling:** **RULE:** **UTILIZE `:host-context(selector)` pseudo-class selector to apply styles to a component based on the presence of *ancestor selectors* in the component's *context*.**  `:host-context()` allows for context-aware component styling based on parent classes, attributes, or other selectors in the DOM tree. **Rationale:** `:host-context()` enables powerful contextual styling, allowing components to adapt their appearance based on their embedding context within the application, facilitating theming and component variations based on placement.

8.  **`::ng-deep` for Style Encapsulation Piercing (Use Sparingly & Cautiously):** **RULE:** **AVOID using `::ng-deep` (or shadow-piercing descendant combinators like `/deep/` or `>>>` - deprecated but sometimes encountered in legacy code) *unless absolutely necessary* to pierce Angular's style encapsulation and style *descendant elements* that are *not part of the component's own template* (e.g., styling elements within child components or global library components that you cannot directly modify).** Use `::ng-deep` very sparingly and with caution as it breaks encapsulation and can lead to specificity issues and style leakage.  **Rationale:** `::ng-deep` circumvents Angular's component style encapsulation and should be used only as a last resort when no other styling approach is feasible. Overuse of `::ng-deep` weakens encapsulation and can create maintenance challenges.  Consider alternatives like component theming, input properties for styling child components, or restructuring component composition if possible to avoid `::ng-deep`.

9.  **SCSS Nesting for Component Structure & Readability:** **RULE:** **LEVERAGE SCSS nesting effectively within component stylesheets to mirror the *component's HTML structure* and improve style *readability* and *organization*.** Nest selectors within component SCSS to reflect the hierarchy of HTML elements in the component's template. Avoid overly deep nesting which can increase specificity and reduce readability. **Rationale:** SCSS nesting, used judiciously to mirror HTML structure, makes component stylesheets more organized, readable, and maintainable by visually representing the relationship between CSS rules and HTML elements.

**III. SCSS Feature Utilization Rules (Organization & Efficiency):**

10. **SCSS Variables for Theming & Reusability (Component & Global Scope):** **RULE:** **DEFINE SCSS variables extensively in Angular components (for component-specific theming) and in global stylesheet files (for application-wide theming and design tokens).** Use component-scoped variables for component-specific style customization and `:root` variables (or separate global SCSS files imported using `@use`) for application-wide theme settings.  **Rationale:** SCSS variables, used at both component and global levels, promote theming, reusability, and consistency. Component-scoped variables enhance component encapsulation and customization, while global variables provide a central source of design tokens for the entire application.

11. **SCSS Mixins for Reusable Style Patterns:** **RULE:** **UTILIZE SCSS Mixins to encapsulate and reuse *common style patterns*, *responsive styles*, *vendor prefixes*, or sets of CSS properties that are applied repeatedly across components or stylesheets.**  Create mixins for frequently used style combinations, responsive behavior, or browser compatibility prefixes to promote DRY (Don't Repeat Yourself) principles in SCSS code. **Rationale:** SCSS Mixins are essential for code reusability and reducing redundancy in SCSS stylesheets. Mixins allow for encapsulating and applying common style patterns efficiently, making SCSS code more maintainable and DRY.

12. **SCSS Functions for Dynamic Value Calculation (If Necessary):** **RULE:** **USE SCSS Functions *judiciously* for dynamic CSS value calculations or more complex style logic when variables and mixins are not sufficient.**  Create functions to perform calculations, manipulate colors, or implement custom logic for generating CSS values. Avoid overly complex functions if simpler SCSS features can achieve the same result.  **Rationale:** SCSS Functions offer programmatic control over CSS value generation for advanced styling scenarios. Use them when needed for dynamic calculations but maintain function simplicity and avoid over-complicating style logic.

13. **SCSS Modules (`@use`, `@forward`) for Code Organization & Namespace Management:** **RULE:** **UTILIZE SCSS Modules (`@use` and `@forward` directives in Angular 19+ - if project is set up to use SCSS modules)** to organize SCSS code into modular files, create namespaces, and manage stylesheet dependencies.** Use `@use` to import and namespace SCSS files within components or other stylesheets, preventing naming conflicts and improving modularity. Use `@forward` to re-export parts of modules for easier access in other parts of the application. **Rationale:** SCSS Modules (using `@use` and `@forward`) provide a modern, robust mechanism for organizing large SCSS codebases into modular, maintainable units. Namespaces prevent naming collisions, and `@forward` facilitates controlled sharing of styles across modules.  (Note: Angular CLI setup may need configuration to fully leverage SCSS Modules).

**IV. Performance & Accessibility SCSS Rules:**

14. **Performance-Focused SCSS - Minimize Layout Triggers & Complex CSS:** **RULE:** **WRITE SCSS code with performance in mind.**  Avoid SCSS that generates CSS rules that trigger layout thrashing, excessive repaints, or inefficient CSS selectors. Prioritize SCSS that leads to performant CSS output, leveraging hardware-accelerated properties (like `transform` and `opacity`) and minimizing browser layout recalculations. (Refer to CSS Animation & Transition Rules for performance property guidelines, applicable also in general SCSS). **Rationale:** Efficient SCSS leads to performant CSS, which is crucial for smooth rendering and a responsive user experience, especially on less powerful devices.

15. **Accessibility-Considerate SCSS (Contrast, Focus Styles, Semantic Styling):** **RULE:** **GENERATE SCSS that facilitates accessible designs.** Ensure generated CSS:
    *   Provides *sufficient color contrast* for text and UI elements (use color contrast tools to verify).
    *   Implements *clear and visible focus styles* for interactive elements (buttons, links, form controls) to enhance keyboard navigation.
    *   Styles *semantic HTML elements* appropriately, enhancing their default presentation while maintaining semantic meaning.
    *   Does *not* rely solely on color to convey information (provide alternative visual cues for color-blind users).  **Rationale:**  Accessible CSS ensures that web applications are usable by everyone, including users with disabilities. Following accessibility guidelines in SCSS/CSS is a fundamental aspect of responsible web development.

**V. Maintainability & Organization SCSS Rules:**

16. **BEM or OOCSS or Similar Methodologies for Scalable CSS (Component Focus):** **RULE:** **Employ CSS methodologies like BEM (Block-Element-Modifier), OOCSS (Object-Oriented CSS), or similar component-focused styling approaches to maintain a scalable and organized SCSS codebase.**  Use BEM or OOCSS principles for class naming conventions and component-based style structuring to improve CSS modularity, prevent naming collisions, and enhance stylesheet maintainability in Angular applications.  Adapt BEM or OOCSS principles to fit Angular's component-scoped styling model naturally.  **Rationale:**  CSS methodologies provide structure and naming conventions that are essential for managing large CSS projects and ensuring long-term stylesheet maintainability, scalability, and team collaboration. Component-focused methodologies align well with Angular's component-based architecture.

17. **Logical SCSS File Structure & Sections (Component & Global Styles):** **RULE:** **ORGANIZE SCSS files logically, both at the *component level* (within component folders) and at the *global level* (for application-wide styles).** Within component SCSS files, structure styles into logical sections (e.g., layout, typography, states, variations). For global SCSS, organize into files for variables, mixins, base styles, components (if global component styles are needed - use sparingly), utilities, and layout styles. **Rationale:**  Clear SCSS file structure and logical sections within files make stylesheets easier to navigate, understand, and maintain, especially in larger Angular projects.

18. **Descriptive Class Names - Semantic & Purposeful:** **RULE:** **USE meaningful and descriptive class names that clearly indicate the *purpose*, *functionality*, or *visual style* of the element being styled.** Class names should be human-readable and reflect the role of the styled element. Avoid generic, presentational class names or overly abbreviated class names that lack clarity. (Adhere to BEM/OOCSS naming conventions if using those methodologies). **Rationale:** Descriptive class names are crucial for stylesheet maintainability and code understanding. Semantic class names communicate the intent and function of styles, making CSS code self-documenting and easier for developers to work with.

19. **SCSS Comments - Explain Complex Styles & Logic:** **RULE:** **COMMENT SCSS code *judiciously* to explain complex style rules, non-obvious SCSS logic (e.g., complex functions, intricate mixin usages), or specific design decisions.**  Use comments to clarify SCSS code where necessary, particularly for parts of the stylesheet that might not be immediately understandable or that implement more advanced SCSS techniques. Avoid over-commenting simple and self-explanatory SCSS rules. **Rationale:** Comments in SCSS code are essential for improving code understandability, maintainability, and for communicating complex styling intent to other developers (or future AI iterations).  Target comments strategically at parts of the stylesheet where explanation would be most beneficial.

**VI. AI Agent Verification Checklist (Angular SCSS Generation):**

Before finalizing generated Angular SCSS code, verify adherence to these rules using the following checklist:

*   [ ] **Semantic Selectors & Meaningful Classes:** Does the SCSS code prioritize semantic element selectors and meaningful CSS classes (avoiding generic `div/span` selectors and IDs where classes are more appropriate)?
*   [ ] **Efficient Selectors & Specificity Management:** Are selectors efficient and specificity minimized? Is `!important` avoided?
*   [ ] **Responsive Design Implementation:** Are `@media` queries and flexible units ( `rem`, `em`, `vw`, `vh`, `%` ) used for responsive layouts and typography?
*   [ ] **CSS Variables for Theming & Consistency:** Are CSS variables (`:root` and component-scoped) extensively used for theming, reusable values, and consistency?
*   [ ] **Component-Scoped Styles (Encapsulation):** Is SCSS code generated as component-scoped styles within `.component.scss` files?
*   [ ] **`:host` Selector Usage:** Is `:host` selector used appropriately to style the component's host element?
*   [ ] **SCSS Nesting for Structure & Readability:** Is SCSS nesting used effectively to mirror component HTML structure and improve readability (without over-nesting)?
*   [ ] **SCSS Mixins for Reusability:** Are SCSS Mixins used to encapsulate and reuse common style patterns, responsive rules, or vendor prefixes?
*   [ ] **Performance-Focused SCSS (Minimize Layout Impact):** Is SCSS code written with performance in mind, minimizing layout triggers and inefficient CSS?
*   [ ] **Accessibility-Considerate SCSS (Contrast & Focus):** Does SCSS code address accessibility by ensuring sufficient color contrast and clear focus styles for interactive elements?
*   [ ] **BEM/OOCSS or Similar Methodology:** Is a CSS methodology like BEM or OOCSS used for class naming and stylesheet organization to ensure scalability and maintainability?
*   [ ] **Logical SCSS File Structure & Sections:** Are SCSS files (component and global) logically structured and organized into relevant sections (variables, mixins, layout, typography, components, utilities)?
*   [ ] **Descriptive Class Names (Semantic & Purposeful):** Are class names descriptive, meaningful, and indicative of element purpose or visual style (following BEM/OOCSS conventions if applicable)?
*   [ ] **SCSS Comments for Complex Styles:** Are comments used strategically to explain complex SCSS code, logic, or non-obvious style rules?
