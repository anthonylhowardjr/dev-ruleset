# Angular Performance Generation Ruleset for AI Agents: Signals, Defer, and Optimal Templates (Angular 19+)

**Objective:** To provide a concise ruleset for AI agents to generate **highly performant**, **efficient**, and **optimized** Angular components in Angular 19 and beyond. This ruleset focuses on maximizing performance by leveraging Signals, `@defer`, OnPush change detection, and optimal template strategies.

**I. Core Performance Principles: Prioritize Efficiency**

1.  **Performance First Design:** **RULE:** **ALWAYS prioritize performance as a primary design constraint in Angular component generation.** Every code decision should be evaluated for its potential performance impact, especially on user experience metrics like load time, responsiveness, and frame rate. **Rationale:** Performance is paramount for a positive user experience. Efficient Angular code is critical for application responsiveness and scalability.

2.  **Signals for Reactive State - Performance Foundation:** **RULE:** **UTILIZE Angular Signals as the *cornerstone* for reactive state management.** Embrace Signals API (`signal()`, `computed()`, `effect()`, `input()`, `output()`) as the preferred method for managing component state, derived data, inputs, and outputs due to their inherent efficiency and optimized change detection. **Rationale:** Signals provide the most performant and streamlined approach to reactive programming in Angular 19+, minimizing change detection overhead.

3.  **Deferred Loading with `@defer` for Initial Load Optimization:** **RULE:** **STRATEGICALLY use `@defer` blocks to implement deferred loading for non-critical UI sections and dependencies.**  Identify UI elements and components that are not essential for the initial user experience and wrap them in `@defer` blocks to reduce the initial bundle size and improve initial render performance. **Rationale:** `@defer` is a powerful tool for optimizing initial page load and improving Core Web Vitals by lazy-loading non-essential resources and UI elements.

4.  **OnPush Change Detection for Subtree Optimization:** **RULE:** **CONFIGURE *all standalone components* with `ChangeDetectionStrategy.OnPush` as the default strategy.** Leverage OnPush to enable Angular to efficiently skip change detection cycles for component subtrees that are not impacted by state changes, minimizing unnecessary computations. **Rationale:** OnPush change detection is crucial for large Angular applications, significantly reducing change detection overhead by only checking components when their inputs or events trigger updates.

5.  **Minimize Template Computation - Pre-compute Values:** **RULE:** **AVOID calling methods directly in Angular templates.**  Pre-compute all necessary values in the component class using Signals or computed properties and bind directly to these pre-computed values in the template. Keep templates focused on simple data display, not complex logic or function calls. **Rationale:** Method calls in templates are re-executed on *every* change detection cycle, potentially causing performance bottlenecks. Pre-computation optimizes performance by calculating values only when dependencies change.

**II. `@defer` Block Optimization Rules: Strategic Lazy Loading**

6.  **`@defer` for Non-Critical UI Sections:** **RULE:** **TARGET non-critical UI elements, components, and content sections for `@defer` blocks.**  Prioritize deferring elements that are below-the-fold, less frequently used, or not essential for the initial user journey or critical path rendering. **Rationale:** Deferring non-critical UI elements provides the most significant performance benefit during initial load by delaying the loading of resources and rendering for elements not immediately needed by the user.

7.  **Utilize `@defer` Sub-blocks for Loading States:** **RULE:** **ALWAYS use `@defer` sub-blocks (`@placeholder`, `@loading`, `@error`) to provide clear visual feedback to the user during deferred loading.** Implement `@placeholder` to maintain layout and prevent content reflows, `@loading` to indicate loading progress, and `@error` to handle loading failures gracefully.  **Rationale:** Sub-blocks improve user experience during deferred loading by providing feedback and maintaining a smoother visual flow, avoiding jarring content jumps and indicating loading status.

8.  **Choose Appropriate `@defer` Triggers - Context is Key:** **RULE:** **SELECT `@defer` triggers STRATEGICALLY based on the nature and usage pattern of the deferred content.**  Use `on viewport` for below-the-fold content, `on interaction`/`on hover` for content revealed on user interaction, `on timer` for time-delayed loading, `when` for conditional loading based on application state, and consider prefetch strategies (`prefetch on idle`) to load resources proactively. **Rationale:** Choosing the right trigger ensures deferred content is loaded at the optimal time for user experience, balancing performance gains with user interaction and perceived responsiveness.

9.  **Optimize `@defer` `minimum` and `after` Parameters (Loading and Placeholder):** **RULE:** **Experiment with `minimum` and `after` parameters in `@placeholder` and `@loading` sub-blocks to fine-tune loading indicators and avoid UI flicker.**  Set `minimum` duration for placeholders to prevent rapid placeholder flashes for fast-loading deferred content. Use `after` in `@loading` to delay the loading indicator until a loading threshold is reached to avoid unnecessary loading animations for very quick loading scenarios. **Rationale:** Fine-tuning `minimum` and `after` parameters refines the user experience during deferred loading by reducing visual noise, preventing flicker, and providing loading indicators only when meaningfully needed.

**III. OnPush Change Detection Optimization Rules: Subtree Efficiency**

10. **Standalone Components & OnPush Enforcement:** **RULE:** **ENSURE *all* generated Angular components are STANDALONE and explicitly configured with `ChangeDetectionStrategy.OnPush`.** Enforce OnPush as the default and *only* allowed change detection strategy for AI-generated Angular components. **Rationale:**  OnPush is fundamental for performance optimization in Angular. Standalone components combined with OnPush promote a modular, efficient, and performant component architecture.

11. **Immutable Data Inputs for OnPush Benefits:** **RULE:** **When designing components with OnPush, ensure that inputs are treated as *immutable data*.** When input values need to be updated, always replace input objects or arrays with *new references*, triggering OnPush change detection effectively. Avoid mutating input objects directly, as this can bypass OnPush change detection and lead to unexpected behavior. **Rationale:** OnPush relies on reference changes in inputs to trigger change detection. Immutable data patterns are essential for leveraging OnPush efficiently and predictably.

12. **Component Decomposition for OnPush Optimization:** **RULE:** **STRUCTURE Angular applications into a component tree optimized for OnPush.** Decompose UI into smaller, independent components where data flow is clearly defined via inputs and outputs, maximizing the effectiveness of OnPush change detection to skip large portions of the component tree during updates. **Rationale:**  A well-structured component tree designed for OnPush is crucial for maximizing the performance benefits of OnPush change detection in large applications, enabling Angular to efficiently update only relevant parts of the UI.

**IV. Computation & Template Optimization Rules: Minimize Overhead**

13. **Computed Signals over Template Methods - Pre-computation Essential:** **RULE:** **For all values displayed or used multiple times in templates that are derived from component state, USE `computed()` signals for pre-computation in the component class.** **AVOID directly calling component methods or complex logic within Angular templates.** Bind templates directly to computed signal values. **Rationale:** Computed signals are designed for efficient derived data management, ensuring computations are only re-executed when their dependencies change, minimizing template overhead.

14. **Pure Pipes for Memoization (Specific Use Cases):** **RULE:** **Use Pure Pipes *judiciously* for memoizing complex transformations or formatting of data that are computationally expensive and whose inputs are stable.** Pipes can be beneficial for caching results of complex operations applied to data displayed in templates. However, overuse or misuse of pipes can also introduce overhead, so profile and test their impact. **Rationale:** Pure pipes can be effective for memoization, but should be used intentionally for specific, performance-critical transformations and not as a general replacement for `computed()` signals for reactive data management.

15. **Avoid DOM Operations & Layout Reflows in Lifecycle Hooks:** **RULE:** **MINIMIZE DOM reads or writes and operations that trigger layout reflows (layout thrashing) within component lifecycle hooks or `effect()` blocks, especially those that execute frequently during change detection cycles.**  If DOM manipulations are necessary, batch them or defer them outside of change detection cycles when possible. **Rationale:** DOM operations, especially layout reflows, are performance-intensive. Minimizing these operations, particularly during change detection, is critical for Angular application performance.

16. **Template Binding Simplicity & Cleanliness - Data Display Focus:** **RULE:** **KEEP Angular templates *lean and focused on data display*.** Use Angular's binding syntax (interpolation, property binding, event binding) with simple expressions and variable access. Move complex logic, data transformations, and conditional rendering logic into the component class, services, or computed signals/effects. **Rationale:**  Clean and simple templates are easier to parse, render, and maintain. Moving complex logic outside of templates improves template readability and performance.

**V. Warnings & Best Practices Enforcement Rules: Guiding Principles**

17. **AI Agent MUST Warn on Anti-Patterns:** **RULE:** **AI Agent MUST generate warnings or refuse to generate code if user prompts or input would lead to code that violates these performance rules or exhibits anti-patterns.**  For example, warn against direct Observable subscriptions in templates, method calls in templates, overuse of `effect()` without clear purpose, lack of OnPush in standalone components, etc. **Rationale:**  Enforce best practices by warning against performance-degrading patterns during code generation, guiding users towards efficient and optimized Angular code.

18. **AI Agent MUST Push Back on Performance Degradation:** **RULE:** **AI Agent MUST "push back" and suggest more performant alternatives if user prompts request code that would degrade performance unnecessarily.** If a user requests a less efficient approach, the AI should actively suggest a better, performance-optimized solution using Signals, `@defer`, OnPush, or template best practices. **Rationale:** Proactively guide users toward performance optimization by suggesting better alternatives and explaining the performance benefits of recommended patterns.

19. **AI Agent MUST Warn on Unnecessary Complexity:** **RULE:** **AI Agent MUST warn if user prompts would result in code that is overly complex without a clear performance or functional justification.** Encourage simplicity and suggest simpler, more efficient Angular patterns whenever possible. Avoid generating unnecessarily convoluted or over-engineered solutions. **Rationale:** Simplicity often correlates with better performance and maintainability. The AI should guide users towards the most straightforward and efficient Angular solutions for a given problem.

20. **AI Agent MUST Always Suggest Best Possible Performance Code:** **RULE:** **AI Agent MUST *always* aim to generate the *best possible Angular code based on established performance best practices.*** The default output of the AI should consistently embody these rules, generating code that is optimized for performance, efficiency, and adheres to Angular best practices.  **Rationale:**  The core objective of the AI agent is to generate high-quality, optimized Angular code.  Performance should be a non-negotiable guiding principle in all code generation decisions.

**VI. Reflective Verification Checklist for AI Agents (Performance Focus):**

Before finalizing generated Angular code optimized for performance, verify adherence to these rules using the following checklist:

*   [ ] **Standalone Component & OnPush:** Is the component a standalone component using `ChangeDetectionStrategy.OnPush`?
*   [ ] **Signals for State Management (Primary):** Are Signals API ( `signal()`, `computed()`, `effect()`, `input()`, `output()` ) used as the core mechanism for component state management?
*   [ ] **`@defer` for Non-Critical UI:** Are `@defer` blocks strategically used to lazy-load non-critical UI sections and dependencies?
*   [ ] **`@defer` Sub-blocks for Loading UI:** Are `@placeholder`, `@loading`, `@error` sub-blocks implemented within `@defer` blocks for user feedback?
*   [ ] **Optimized `@defer` Triggers & Parameters:** Are appropriate `@defer` triggers selected based on content and user interaction patterns? Are `minimum` and `after` parameters tuned for `@placeholder` and `@loading`?
*   [ ] **Computed Signals over Template Methods:** Are `computed()` signals used to pre-compute values instead of calling methods directly in templates?
*   [ ] **Pure Pipes Judiciously for Memoization (Specific Cases):** Are Pure Pipes used only for specific performance-critical data transformations, not for general state management or as a substitute for `computed()` signals?
*   [ ] **Minimal DOM Operations in Lifecycle Hooks/Effects:** Are DOM operations and layout reflow triggers minimized within lifecycle hooks and `effect()` blocks?
*   [ ] **Template Simplicity - Data Binding Focus:** Are templates kept lean, focused on data binding with simple expressions, and free of complex logic or function calls?
*   [ ] **Warnings and Best Practices Adherence:** Does the AI Agent generate warnings or push back against code that violates performance best practices or introduces unnecessary complexity?
